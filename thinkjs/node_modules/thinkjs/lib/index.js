'use strict';

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

require('./core/think.js');

var _default = (function () {
  /**
   * init
   * @param  {Object} options [project options]
   * @return {}         []
   */

  function _default() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _default);

    //extend options to think
    think.extend(think, this.getPath(), options);
    //parse data from process arguments
    var i = 2;
    var argv = process.argv[i];
    //get app mode from argv
    if (argv === 'production' || argv === 'development' || argv === 'testing') {
      think.env = argv;
      i++;
    }
    argv = process.argv[i];
    //get port or cli url from argv
    if (argv) {
      if (/^\d+$/.test(argv)) {
        think.port = argv;
      } else {
        think.cli = argv;
      }
    }
    //get app mode
    think.mode = this.getMode();
  }

  /**
   * get app mode
   * @return {Number} [app mode]
   */

  _default.prototype.getMode = function getMode() {
    var filepath = think.APP_PATH + '/' + think.dirname.controller;
    if (think.isDir(filepath)) {
      var files = _fs2['default'].readdirSync(filepath);
      var flag = files.some(function (file) {
        if (think.isDir(filepath + '/' + file)) {
          return true;
        }
      });
      return flag ? think.mode_normal : think.mode_mini;
    }
    return think.mode_module;
  };

  /**
   * get app path
   * @return {Object} []
   */

  _default.prototype.getPath = function getPath() {
    var filepath = process.argv[1];
    var ROOT_PATH = _path2['default'].dirname(filepath);
    var APP_PATH = _path2['default'].dirname(ROOT_PATH) + '/app';
    return {
      APP_PATH: APP_PATH,
      RESOURCE_PATH: ROOT_PATH,
      ROOT_PATH: ROOT_PATH
    };
  };

  /**
   * check node env
   * @return {Boolean} []
   */

  _default.prototype.checkEnv = function checkEnv() {
    this.checkNodeVersion();
  };

  /**
   * check node version
   * @return {} []
   */

  _default.prototype.checkNodeVersion = function checkNodeVersion() {
    var packageFile = think.THINK_PATH + '/package.json';

    var _JSON$parse = JSON.parse(_fs2['default'].readFileSync(packageFile, 'utf-8'));

    var engines = _JSON$parse.engines;

    var needVersion = engines.node.substr(2);

    var nodeVersion = process.version;
    if (nodeVersion[0] === 'v') {
      nodeVersion = nodeVersion.slice(1);
    }

    if (needVersion > nodeVersion) {
      think.log(function (colors) {
        return colors.red('[ERROR]') + ' ThinkJS need node version >= ' + needVersion + ', current version is ' + nodeVersion + ', please upgrade it.';
      });
      console.log();
      process.exit();
    }
  };

  /**
   * check application filename is lower
   * @return {} []
   */

  _default.prototype.checkFileName = function checkFileName() {
    var files = think.getFiles(think.APP_PATH);
    var reg = /\.(js|html|tpl)$/;
    var uppercaseReg = /[A-Z]+/;
    var filter = function filter(item) {
      if (!reg.test(item)) {
        return;
      }
      //ignore files in config/locale
      if (item.indexOf('/' + think.dirname.locale + '/') > -1) {
        return;
      }
      return true;
    };
    files.forEach(function (item) {
      if (filter(item) && uppercaseReg.test(item)) {
        think.log(function (colors) {
          return colors.yellow('[WARNING]') + (' file `' + item + '` has uppercase chars.');
        });
      }
    });
  };

  /**
   * check dependencies is installed before server start
   * @return {} []
   */

  _default.prototype.checkDependencies = function checkDependencies() {
    var packageFile = think.ROOT_PATH + '/package.json';
    if (!think.isFile(packageFile)) {
      return;
    }
    var data = JSON.parse(_fs2['default'].readFileSync(packageFile, 'utf8'));
    var dependencies = data.dependencies;

    var _loop = function (pkg) {
      if (think.isDir(think.ROOT_PATH + '/node_modules/' + pkg)) {
        return 'continue';
      }
      try {
        require(pkg);
      } catch (e) {
        think.log(function (colors) {
          var msg = colors.red('[ERROR]') + (' package `' + pkg + '` is not installed. ');
          msg += 'please run `npm install` command before start server.';
          return msg;
        }, '', null);
        console.log();
        process.exit();
      }
    };

    for (var pkg in dependencies) {
      var _ret = _loop(pkg);

      if (_ret === 'continue') continue;
    }
  };

  /**
   * get app module list
   * @return {} []
   */

  _default.prototype.getModule = function getModule() {
    //only have default module in mini mode
    if (think.mode === think.mode_mini) {
      think.module = [think.config('default_module')];
      return think.module;
    }
    var modulePath = think.APP_PATH;
    if (think.mode === think.mode_normal) {
      modulePath += '/' + think.dirname.controller;
    }
    if (!think.isDir(modulePath)) {
      return [];
    }
    var modules = _fs2['default'].readdirSync(modulePath);
    var denyModuleList = think.config('deny_module_list') || [];
    if (denyModuleList.length > 0) {
      modules = modules.filter(function (module) {
        if (module[0] === '.') {
          return;
        }
        if (denyModuleList.indexOf(module) === -1) {
          return module;
        }
      });
    }
    think.module = modules;
    return modules;
  };

  /**
   * load alias
   * @return {} []
   */

  _default.prototype.loadAlias = function loadAlias() {
    var aliasPath = think.THINK_LIB_PATH + '/config/sys/alias.js';
    thinkCache(thinkCache.ALIAS, require(aliasPath));
  };

  /**
   * load alias module export
   * @return {} []
   */

  _default.prototype.loadAliasExport = function loadAliasExport() {
    var alias = thinkCache(thinkCache.ALIAS);
    for (var key in alias) {
      if (thinkCache(thinkCache.ALIAS_EXPORT, key)) {
        continue;
      }
      thinkCache(thinkCache.ALIAS_EXPORT, key, think.require(key));
    }
  };

  /**
   * load config
   * @return {} []
   */

  _default.prototype.loadConfig = function loadConfig() {
    //sys config
    var config = think.getModuleConfig(true);
    //common module config
    var commonConfig = think.getModuleConfig();
    var configs = think.extend(config, commonConfig);
    thinkCache(thinkCache.CONFIG, configs);
    var modules = this.getModule();

    //load modules config
    modules.forEach(function (module) {
      think.getModuleConfig(module);
    });
  };

  /**
   * check module config
   * @return {} []
   */

  _default.prototype.checkModuleConfig = function checkModuleConfig() {
    if (think.mode !== think.mode_module) {
      return;
    }
    // check module config
    // some config must be set in common module
    var keys = [],
        errorKey = 'error_config_key';
    var errorConfigKeys = thinkCache(thinkCache.COLLECTION, errorKey);
    if (think.isEmpty(errorConfigKeys)) {
      thinkCache(thinkCache.COLLECTION, errorKey, []);
      errorConfigKeys = thinkCache(thinkCache.COLLECTION, errorKey);
    }

    var checkModuleConfig = function checkModuleConfig(module) {
      if (keys.length === 0) {
        keys = _Object$keys(require(think.THINK_LIB_PATH + '/config/config.js'));
      }
      var configFilePath = think.getPath(module, think.dirname.config) + '/config.js';
      if (!think.isFile(configFilePath)) {
        return;
      }
      var config = require(configFilePath);
      keys.forEach(function (key) {
        if (config[key] && errorConfigKeys.indexOf(key) === -1) {
          errorConfigKeys.push(key);
          think.log(function (colors) {
            return colors.red('config key `' + key + '` can not be set in `' + module + '` module, must be set in `common` module');
          }, 'CONFIG');
        }
      });
    };

    var modules = this.getModule();
    //load modules config
    modules.forEach(function (module) {
      if (module !== 'common') {
        checkModuleConfig(module);
      }
    });
  };

  /**
   * load route
   * @return {} []
   */

  _default.prototype.loadRoute = function loadRoute() {
    think.route();
  };

  /**
   * load adapter
   * @return {} []
   */

  _default.prototype.loadAdapter = function loadAdapter() {
    think.loadAdapter();
  };

  /**
   * load middleware
   * @return {} []
   */

  _default.prototype.loadMiddleware = function loadMiddleware() {
    var paths = [think.THINK_LIB_PATH + '/middleware', '' + think.getPath(undefined, think.dirname.middleware)];
    think.alias('middleware', paths);
    //middleware base class
    think.middleware.base = think.require('middleware_base');
  };

  /**
   * load hook
   * @return {} []
   */

  _default.prototype.loadHook = function loadHook() {
    var hookPath = think.THINK_LIB_PATH + '/config/hook.js';
    var hook = think.extend({}, require(hookPath));
    var file = think.getPath(undefined, think.dirname.config) + '/hook.js';
    var data = think.extend({}, think.safeRequire(file));
    var key = undefined,
        value = undefined;
    for (key in data) {
      value = data[key];
      if (!(key in hook)) {
        hook[key] = data[key];
      } else if (value[0] === 'append' || value[0] === 'prepend') {
        var flag = value.shift();
        if (flag === 'append') {
          hook[key] = hook[key].concat(value);
        } else {
          hook[key] = value.concat(hook[key]);
        }
      } else {
        hook[key] = value;
      }
    }
    thinkCache(thinkCache.HOOK, hook);
  };

  /**
   * load controller, model, logic, service files
   * @return {} []
   */

  _default.prototype.loadMVC = function loadMVC() {
    var types = {
      model: ['base', 'relation', 'mongo', 'adv'],
      controller: ['base', 'rest'],
      logic: ['base'],
      service: ['base']
    };

    var _loop2 = function (type) {
      think.alias(type, think.THINK_LIB_PATH + '/' + type);
      types[type].forEach(function (item) {
        think[type][item] = think.require(type + '_' + item);
      });
      think.module.forEach(function (module) {
        var moduleType = module + '/' + type;
        var filepath = think.getPath(module, think.dirname[type]);
        think.alias(moduleType, filepath, true);
      });
    };

    for (var type in types) {
      _loop2(type);
    }
  };

  /**
   * load bootstrap
   * @return {} []
   */

  _default.prototype.loadBootstrap = function loadBootstrap() {
    var paths = [think.THINK_LIB_PATH + '/bootstrap', think.getPath(think.dirname.common, think.dirname.bootstrap)];
    paths.forEach(function (item) {
      if (!think.isDir(item)) {
        return;
      }
      var files = _fs2['default'].readdirSync(item);

      //must reload all bootstrap files.
      //may be register adapter in bootstrap file
      if (think.config('auto_reload')) {
        var AutoReload = require('./util/auto_reload.js');
        //AutoReload.rewriteSysModuleLoad();
        var instance = new AutoReload(item, function () {});
        instance.clearFilesCache(files.map(function (file) {
          return item + '/' + file;
        }));
      }

      files.forEach(function (file) {
        var extname = _path2['default'].extname(file);
        if (extname !== '.js') {
          return;
        }
        think.safeRequire(item + '/' + file);
      });
    });
  };

  /**
   * load template file
   * add template files to cache
   * @return {} []
   */

  _default.prototype.loadTemplate = function loadTemplate() {
    var data = {};

    var add = function add(filepath) {
      if (!think.isDir(filepath)) {
        return;
      }
      var files = think.getFiles(filepath);
      files.forEach(function (file) {
        var key = _path2['default'].normalize(filepath + '/' + file);
        data[key] = true;
      });
    };

    var _think$config = think.config('view');

    var root_path = _think$config.root_path;

    if (root_path) {
      add(root_path);
    } else {
      think.module.forEach(function (module) {
        add(think.getPath(module, think.dirname.view));
      });
    }
    thinkCache(thinkCache.TEMPLATE, data);
  };

  /**
   * load system error message
   * @return {} []
   */

  _default.prototype.loadError = function loadError() {
    var message = require(think.THINK_LIB_PATH + '/config/sys/error.js');
    thinkCache(thinkCache.ERROR, message);
  };

  /**
   * load all config or modules
   * @return {} []
   */

  _default.prototype.load = function load() {
    //clear all cache for reload
    thinkCache(thinkCache.ALIAS, null);
    thinkCache(thinkCache.ALIAS_EXPORT, null);
    thinkCache(thinkCache.MODULE_CONFIG, null);
    think.route(null);

    this.loadConfig();
    this.loadRoute();
    this.loadAlias();
    this.loadAdapter();
    this.loadMiddleware();
    this.loadMVC();
    this.loadHook();
    this.loadTemplate();
    this.loadError();

    this.loadBootstrap();

    this.checkModuleConfig();

    //load alias export at last
    //this.loadAliasExport();
  };

  /**
   * capture error
   * @return {} []
   */

  _default.prototype.captureError = function captureError() {
    process.on('uncaughtException', function (err) {
      var msg = err.message;
      err = think.error(err, 'port:' + think.config('port'));
      think.log(err);
      if (msg.indexOf(' EADDRINUSE ') > -1) {
        process.exit();
      }
    });
  };

  /**
   * start
   * @return {} []
   */

  _default.prototype.start = function start() {
    this.checkEnv();
    this.checkFileName();
    this.checkDependencies();
    this.load();
    this.captureError();
    if (think.config('auto_reload')) {
      this.autoReload();
    }
  };

  /**
   * auto reload user modified files
   * @return {} []
   */

  _default.prototype.autoReload = function autoReload() {
    //it auto reload by watch compile
    if (this.compileCallback) {
      return;
    }
    var instance = this.getReloadInstance();
    instance.run();
  };

  /**
   * get auto reload class instance
   * @param  {String} srcPath []
   * @return {Object}         []
   */

  _default.prototype.getReloadInstance = function getReloadInstance(srcPath) {
    var _this = this;

    srcPath = srcPath || think.APP_PATH;
    var AutoReload = require('./util/auto_reload.js');
    AutoReload.rewriteSysModuleLoad();
    var instance = new AutoReload(srcPath, function () {
      _this.load();
    });
    return instance;
  };

  /**
   * use babel compile code
   * @return {} []
   */

  _default.prototype.compile = function compile(srcPath, outPath) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    if (think.isObject(srcPath)) {
      options = srcPath;
      srcPath = '';
    } else if (srcPath === true) {
      options = { log: true };
      srcPath = '';
    }
    srcPath = srcPath || think.ROOT_PATH + '/src';
    outPath = outPath || think.APP_PATH;

    if (!think.isDir(srcPath)) {
      return;
    }
    var reloadInstance = this.getReloadInstance(outPath);
    this.compileCallback = function (changedFiles) {
      reloadInstance.clearFilesCache(changedFiles);
    };

    var WatchCompile = require('./util/watch_compile.js');
    var instance = new WatchCompile(srcPath, outPath, options, this.compileCallback);
    instance.run();

    think.autoCompile = true;
    //get app mode
    think.mode = this.getMode();
  };

  /**
   * run
   * @return {} []
   */

  _default.prototype.run = function run() {
    this.start();
    return think.require('app').run();
  };

  /**
   * load, convenient for plugins
   * @return {} []
   */

  _default.load = function load() {
    var instance = new this();
    instance.load();
  };

  return _default;
})();

exports['default'] = _default;
module.exports = exports['default'];