'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

/**
 * route array rules:
 * [
 *   [/^user\/(\d+)/, 'home/user/detail?id=:1'],
 *   [/^usr\/(\d+)/, {
 *     get: 'home/user/detail?id=:1',
 *     post: 'home/user/delete?id=:1'
 *   }],
 *   ...
 * ]
 *
 * route object rules:
 * {
 *   admin: {
 *     reg: /^admin/,
 *     children: [
 *       
 *     ]
 *   }
 * }
 */

var _default = (function (_think$middleware$base) {
  _inherits(_default, _think$middleware$base);

  function _default() {
    _classCallCheck(this, _default);

    _think$middleware$base.apply(this, arguments);
  }

  /**
   * run
   * @return {Promise} []
   */

  _default.prototype.run = function run() {
    var rules;
    return _regeneratorRuntime.async(function run$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (this.config('route_on')) {
            context$2$0.next = 2;
            break;
          }

          return context$2$0.abrupt('return', this.parsePathname());

        case 2:
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(think.route());

        case 4:
          rules = context$2$0.sent;
          return context$2$0.abrupt('return', this.parse(rules));

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * parse routes
   * @param  {Array} routes [routes]
   * @return {}        []
   */

  _default.prototype.parse = function parse(rules) {
    this.cleanPathname();
    if (think.isArray(rules)) {
      return this.parseRules(rules);
    }
    for (var _module2 in rules) {
      var reg = rules[_module2].reg;
      if (!reg || reg.test(this.http.pathname)) {
        this.module = _module2;
        return this.parseRules(rules[_module2].children);
      }
    }
    return this.parsePathname();
  };

  /**
   * parse array rules
   * @param  {Array} rules []
   * @return {}       []
   */

  _default.prototype.parseRules = function parseRules(rules) {
    var length = rules.length;
    var pathname = this.http.pathname;
    if (length === 0 || !pathname) {
      return this.parsePathname();
    }
    var match = undefined,
        item = undefined,
        route = undefined,
        rule = undefined;
    for (var i = 0; i < length; i++) {
      item = rules[i];
      route = this.getRoute(item[1]);
      if (!route) {
        continue;
      }
      rule = item[0];
      //regexp route
      if (think.isRegExp(rule)) {
        match = pathname.match(rule);
        if (match) {
          return this.parseRegExpRule(match, route);
        }
      }
      //is string route
      else if (this.checkUrlMatch(rule)) {
          return this.parseRoute(route);
        }
    }
    return this.parsePathname();
  };

  /**
   * remove / start | end of pathname
   * @return {} []
   */

  _default.prototype.cleanPathname = function cleanPathname() {
    var pathname = this.http.pathname;
    if (pathname[0] === '/') {
      pathname = pathname.slice(1);
    }
    if (pathname.slice(-1) === '/') {
      pathname = pathname.slice(0, -1);
    }
    this.http.pathname = pathname;
  };

  /**
   * parse pathname
   * @return {} []
   */

  _default.prototype.parsePathname = function parsePathname() {
    var pathname, http, paths, module, controller, action;
    return _regeneratorRuntime.async(function parsePathname$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          pathname = this.http.pathname, http = this.http;

          if (pathname) {
            context$2$0.next = 6;
            break;
          }

          this.http.module = this.getModule();
          this.http.controller = this.getController();
          this.http.action = this.getAction();
          return context$2$0.abrupt('return');

        case 6:
          paths = pathname.split('/');
          module = undefined, controller = undefined, action = undefined;

          if (think.mode !== think.mode_mini) {
            module = paths[0].toLowerCase();
            if (this.module) {
              if (this.module === module) {
                paths.shift();
              } else {
                module = this.module;
              }
            } else if (module && module !== think.dirname.common && think.module.indexOf(module) > -1) {
              paths.shift();
            } else {
              module = '';
            }
          }
          controller = paths.shift();
          action = paths.shift();

          this.parseExtPath(paths);

          this.http.module = this.getModule(module);
          this.http.controller = this.getController(controller);
          this.http.action = this.getAction(action);

          if (this.http.controller) {
            context$2$0.next = 18;
            break;
          }

          this.http.error = new Error(think.locale('CONTROLLER_INVALID', controller, this.http.url));
          return context$2$0.abrupt('return', think.statusAction(400, http));

        case 18:
          if (this.http.action) {
            context$2$0.next = 21;
            break;
          }

          this.http.error = new Error(think.locale('ACTION_INVALID', action, this.http.url));
          return context$2$0.abrupt('return', think.statusAction(400, http));

        case 21:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * parse extra path
   * @param  {Array} paths [extra path]
   * @return {}       []
   */

  _default.prototype.parseExtPath = function parseExtPath(paths) {
    if (paths.length === 0) {
      return;
    }
    if (!think.isArray(paths)) {
      if (paths[0] === '/') {
        paths = paths.slice(1);
      }
      paths = paths.split('/');
    }
    for (var i = 0, _name = undefined, _length = Math.ceil(paths.length) / 2; i < _length; i++) {
      _name = paths[i * 2];
      if (_name) {
        this.http._get[_name] = paths[i * 2 + 1] || '';
      }
    }
  };

  /**
   * check url is match
   * @param  {String} rule [url rule]
   * @return {Boolean}      []
   */

  _default.prototype.checkUrlMatch = function checkUrlMatch(rule) {
    var pathname = this.http.pathname.split('/');
    rule = rule.split('/');
    var i = 0,
        length = rule.length,
        plength = pathname.length,
        item = undefined,
        pitem = undefined;
    //if rule lenth is more then pathname, it will be false
    if (length > plength) {
      return false;
    }
    var match = {};
    for (; i < length; i++) {
      item = rule[i];
      pitem = pathname[i];
      if (item.indexOf(':') === 0) {
        match[item.slice(1)] = pitem;
      } else {
        if (pitem.toLowerCase() !== item.toLowerCase()) {
          return false;
        }
      }
    }
    //append match data to this.http._get
    for (var key in match) {
      this.http._get[key] = match[key];
    }
    if (plength > length) {
      this.parseExtPath(pathname.slice(length));
    }
    return true;
  };

  /**
   * get route
   * @param  {Object} route   []
   * @param  {Array} matches []
   * @return {[type]}         []
   */

  _default.prototype.getRoute = function getRoute(route) {
    if (think.isString(route)) {
      return route;
    }
    for (var method in route) {
      if (method.toUpperCase().indexOf(this.http.method) > -1) {
        return route[method];
      }
    }
    return '';
  };

  /**
   * parse route string
   * @param  {String} route []
   * @return {}       []
   */

  _default.prototype.parseRoute = function parseRoute(route) {
    if (route.indexOf('?') > -1) {
      var urlInfo = _url2['default'].parse(route, true);
      var query = urlInfo.query;
      for (var key in query) {
        if (query[key] || !(key in this.http._get)) {
          this.http._get[key] = query[key];
        }
      }
      route = urlInfo.pathname;
    }
    if (route[0] === '/') {
      route = route.slice(1);
    }
    this.http.pathname = route;
    return this.parsePathname();
  };

  /**
   * parse regexp rule
   * @param  {Array} matches  [route matches]
   * @param  {String | Object} route    [route]
   * @return {Boolean}          []
   */

  _default.prototype.parseRegExpRule = function parseRegExpRule(matches, route) {
    //replace :1, :2 in route
    //such as: group/detail?date=:1&groupId=:2&page=:3
    route = route.replace(/:(\d+)/g, function (a, b) {
      return matches[b] || '';
    });
    var pathname = this.http.pathname.slice(matches[0].length);
    this.parseExtPath(pathname);
    this.parseRoute(route);
  };

  /**
   * check value is lowerCase
   * @param  {String} value []
   * @return {}       []
   */

  _default.prototype.checkLowerCase = function checkLowerCase(value) {
    // if value has - chars, not check, for REST API
    if (value.indexOf('-') > -1) {
      return;
    }
    var lower = value.toLowerCase();
    if (value !== lower) {
      think.log(function (colors) {
        return colors.yellow('[WARNING]') + ' ' + think.locale('URL_HAS_UPPERCASE', value);
      });
    }
  };

  /**
   * get module name
   * @param  {String} module []
   * @return {String}        []
   */

  _default.prototype.getModule = function getModule(module) {
    if (!module || think.mode === think.mode_mini) {
      return think.config('default_module');
    }
    this.checkLowerCase(module);
    return module.toLowerCase();
  };

  /**
   * get controller name
   * @param  {String} controller []
   * @return {String}            []
   */

  _default.prototype.getController = function getController(controller) {
    if (!controller) {
      return think.config('default_controller');
    }
    if (/^\w+$/.test(controller)) {
      this.checkLowerCase(controller);
      return controller.toLowerCase();
    }
    return '';
  };

  /**
   * get action
   * @param  {String} action [action name]
   * @return {String}        []
   */

  _default.prototype.getAction = function getAction(action) {
    if (!action) {
      return think.config('default_action');
    }
    // action name support `-` char, for REST API
    // /api/system/3b6c279c-bd61-f093-c543-56f9ab4300b7
    if (/^[\w\-]+$/.test(action)) {
      this.checkLowerCase(action);
      return action.toLowerCase();
    }
    return '';
  };

  return _default;
})(think.middleware.base);

exports['default'] = _default;
module.exports = exports['default'];