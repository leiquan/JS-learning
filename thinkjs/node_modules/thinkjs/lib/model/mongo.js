'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _baseJs = require('./_base.js');

var _baseJs2 = _interopRequireDefault(_baseJs);

/**
 * mongodb model
 */

var _default = (function (_Base) {
  _inherits(_default, _Base);

  function _default() {
    _classCallCheck(this, _default);

    _Base.apply(this, arguments);
  }

  /**
   * get primary key
   * @return {Promise} []
   */

  _default.prototype.getPk = function getPk() {
    this.pk = '_id';
    return _Promise.resolve(this.pk);
  };

  /**
   * create index from this.indexes
   * http://docs.mongodb.org/manual/core/indexes-introduction/
   * @return {Promise} []
   */

  _default.prototype._createIndexes = function _createIndexes() {
    var storeKey, isSet, indexes;
    return _regeneratorRuntime.async(function _createIndexes$(context$2$0) {
      var _this = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          storeKey = 'mongo_' + this.getTableName() + '_indexes';
          isSet = thinkCache(thinkCache.TABLE, storeKey);

          if (!isSet) {
            context$2$0.next = 4;
            break;
          }

          return context$2$0.abrupt('return');

        case 4:
          indexes = this.indexes;

          if (!think.isEmpty(indexes)) {
            context$2$0.next = 7;
            break;
          }

          return context$2$0.abrupt('return');

        case 7:
          return context$2$0.abrupt('return', think.await(storeKey, function () {
            var promises = [];
            for (var key in indexes) {
              var value = indexes[key];
              if (think.isObject(value)) {
                var options = {};
                var val = {};
                for (var k in value) {
                  //key start with $ is options
                  if (k[0] === '$') {
                    options[k.slice(1)] = value[k];
                  } else {
                    val[k] = value[k];
                  }
                }
                //if value is empty, auto add key itself
                if (think.isEmpty(val)) {
                  val[key] = 1;
                }
                promises.push(_this.createIndex(val, options));
              } else {
                var _value;

                value = (_value = {}, _value[key] = value, _value);
                promises.push(_this.createIndex(value));
              }
            }
            return _Promise.all(promises).then(function () {
              thinkCache(thinkCache.TABLE, storeKey, 1);
            });
          }));

        case 8:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * parse options
   * @param  {Object} options []
   * @return {Promise}         []
   */

  _default.prototype.parseOptions = function parseOptions(oriOpts, extraOptions) {
    var options;
    return _regeneratorRuntime.async(function parseOptions$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          options = think.extend({}, this._options);

          if (think.isObject(oriOpts)) {
            options = think.extend(options, oriOpts, extraOptions);
          }
          //clear options
          this._options = {};
          //get table name
          options.table = options.table || this.getTableName();

          options.tablePrefix = this.tablePrefix;
          options.model = this.getModelName();

          if (!think.isObject(oriOpts)) {
            options = think.extend(options, oriOpts, extraOptions);
          }

          context$2$0.next = 9;
          return _regeneratorRuntime.awrap(this._createIndexes());

        case 9:
          return context$2$0.abrupt('return', this.optionsFilter(options));

        case 10:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * parse data
   * @param  {Object} data []
   * @return {Object}      []
   */

  _default.prototype.parseData = function parseData(data) {
    return data;
  };

  /**
   * get table connection
   * @return {Promise} []
   */

  _default.prototype.collection = function collection(table) {
    table = table || this.getTableName();
    return this.db().collection(table);
  };

  /**
   * add data
   * @param {Object} data    []
   * @param {Object} options []
   */

  _default.prototype.add = function add(data, options) {
    var msg;
    return _regeneratorRuntime.async(function add$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          //copy data
          data = think.extend({}, this._data, data);
          //clear data
          this._data = {};

          if (!think.isEmpty(data)) {
            context$2$0.next = 5;
            break;
          }

          msg = new Error(think.locale('DATA_EMPTY'));
          return context$2$0.abrupt('return', think.reject(msg));

        case 5:
          context$2$0.next = 7;
          return _regeneratorRuntime.awrap(this.parseOptions(options));

        case 7:
          options = context$2$0.sent;
          context$2$0.next = 10;
          return _regeneratorRuntime.awrap(this.beforeAdd(data, options));

        case 10:
          data = context$2$0.sent;

          data = this.parseData(data);
          context$2$0.next = 14;
          return _regeneratorRuntime.awrap(this.db().add(data, options));

        case 14:
          context$2$0.next = 16;
          return _regeneratorRuntime.awrap(this.afterAdd(data, options));

        case 16:
          return context$2$0.abrupt('return', this.db().getLastInsertId());

        case 17:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
  * then add
  * @param  {Object} data       []
  * @param  {Object} where      []
  * @return {}            []
  */

  _default.prototype.thenAdd = function thenAdd(data, where) {
    var _ref2;

    var findData, _ref, insertId;

    return _regeneratorRuntime.async(function thenAdd$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.where(where).find());

        case 2:
          findData = context$2$0.sent;

          if (think.isEmpty(findData)) {
            context$2$0.next = 5;
            break;
          }

          return context$2$0.abrupt('return', (_ref = {}, _ref[this.pk] = findData[this.pk], _ref.type = 'exist', _ref));

        case 5:
          context$2$0.next = 7;
          return _regeneratorRuntime.awrap(this.add(data));

        case 7:
          insertId = context$2$0.sent;
          return context$2$0.abrupt('return', (_ref2 = {}, _ref2[this.pk] = insertId, _ref2.type = 'add', _ref2));

        case 9:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * add multi data
   * @param {Object} data    []
   * @param {} options []
   * @param {} replace []
   */

  _default.prototype.addMany = function addMany(data, options) {
    var err;
    return _regeneratorRuntime.async(function addMany$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (!(!think.isArray(data) || !think.isObject(data[0]))) {
            context$2$0.next = 3;
            break;
          }

          err = new Error(think.locale('DATA_MUST_BE_ARRAY'));
          return context$2$0.abrupt('return', think.reject(err));

        case 3:
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap(this.parseOptions(options));

        case 5:
          options = context$2$0.sent;
          context$2$0.next = 8;
          return _regeneratorRuntime.awrap(this.beforeAdd(data, options));

        case 8:
          data = context$2$0.sent;
          context$2$0.next = 11;
          return _regeneratorRuntime.awrap(this.db().addMany(data, options));

        case 11:
          context$2$0.next = 13;
          return _regeneratorRuntime.awrap(this.afterAdd(data, options));

        case 13:
          return context$2$0.abrupt('return', this.db().getLastInsertId());

        case 14:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * delete data
   * @return {} []
   */

  _default.prototype['delete'] = function _delete(options) {
    var data;
    return _regeneratorRuntime.async(function _delete$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.parseOptions(options));

        case 2:
          options = context$2$0.sent;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap(this.db()['delete'](options));

        case 5:
          data = context$2$0.sent;
          context$2$0.next = 8;
          return _regeneratorRuntime.awrap(this.afterDelete(options));

        case 8:
          return context$2$0.abrupt('return', data.result.n || 0);

        case 9:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * update data
   * @return {Promise} []
   */

  _default.prototype.update = function update(data, options) {
    var pk, _where, result;

    return _regeneratorRuntime.async(function update$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.parseOptions(options));

        case 2:
          options = context$2$0.sent;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap(this.getPk());

        case 5:
          pk = context$2$0.sent;

          if (data[pk]) {
            this.where((_where = {}, _where[pk] = data[pk], _where));
            delete data[pk];
          }
          context$2$0.next = 9;
          return _regeneratorRuntime.awrap(this.db().update(data, options));

        case 9:
          result = context$2$0.sent;
          context$2$0.next = 12;
          return _regeneratorRuntime.awrap(this.afterUpdate(data, options));

        case 12:
          return context$2$0.abrupt('return', result.result.nModified || 0);

        case 13:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * update many data
   * @param  {Promise} dataList []
   * @return {Promise}          []
   */

  _default.prototype.updateMany = function updateMany(dataList, options) {
    var promises;
    return _regeneratorRuntime.async(function updateMany$(context$2$0) {
      var _this2 = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (think.isArray(dataList)) {
            context$2$0.next = 2;
            break;
          }

          return context$2$0.abrupt('return', think.reject(new Error(think.locale('DATA_MUST_BE_ARRAY'))));

        case 2:
          promises = dataList.map(function (data) {
            return _this2.update(data, options);
          });
          return context$2$0.abrupt('return', _Promise.all(promises).then(function (data) {
            return data.reduce(function (a, b) {
              return a + b;
            });
          }));

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * select data
   * @return {Promise} []
   */

  _default.prototype.select = function select(options) {
    var data;
    return _regeneratorRuntime.async(function select$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.parseOptions(options));

        case 2:
          options = context$2$0.sent;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap(this.db().select(options));

        case 5:
          data = context$2$0.sent;
          return context$2$0.abrupt('return', this.afterSelect(data, options));

        case 7:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * count select
   * @param  {Object} options  []
   * @param  {Boolean} pageFlag []
   * @return {Promise}          []
   */

  _default.prototype.countSelect = function countSelect(options, pageFlag) {
    var count, numsPerPage, data, totalPage, result;
    return _regeneratorRuntime.async(function countSelect$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          count = undefined;

          if (think.isBoolean(options)) {
            pageFlag = options;
            options = {};
          } else if (think.isNumber(options)) {
            count = options;
            options = {};
          }

          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(this.parseOptions(options));

        case 4:
          options = context$2$0.sent;

          if (count) {
            context$2$0.next = 9;
            break;
          }

          context$2$0.next = 8;
          return _regeneratorRuntime.awrap(this.options(options).count());

        case 8:
          count = context$2$0.sent;

        case 9:

          options.limit = options.limit || [0, this.config.nums_per_page];

          numsPerPage = options.limit[1];
          data = { numsPerPage: numsPerPage };

          data.currentPage = parseInt(options.limit[0] / options.limit[1] + 1);
          totalPage = Math.ceil(count / data.numsPerPage);

          if (think.isBoolean(pageFlag) && data.currentPage > totalPage) {
            if (pageFlag) {
              data.currentPage = 1;
              options.limit = [0, numsPerPage];
            } else {
              data.currentPage = totalPage;
              options.limit = [(totalPage - 1) * numsPerPage, numsPerPage];
            }
          }
          result = think.extend({ count: count, totalPages: totalPage }, data);

          if (!count) {
            context$2$0.next = 22;
            break;
          }

          context$2$0.next = 19;
          return _regeneratorRuntime.awrap(this.select(options));

        case 19:
          context$2$0.t0 = context$2$0.sent;
          context$2$0.next = 23;
          break;

        case 22:
          context$2$0.t0 = [];

        case 23:
          result.data = context$2$0.t0;
          return context$2$0.abrupt('return', result);

        case 25:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * select one row data
   * @param  {Object} options []
   * @return {Promise}         []
   */

  _default.prototype.find = function find(options) {
    var data;
    return _regeneratorRuntime.async(function find$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.parseOptions(options, { limit: 1 }));

        case 2:
          options = context$2$0.sent;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap(this.db().select(options));

        case 5:
          data = context$2$0.sent;
          return context$2$0.abrupt('return', this.afterFind(data[0] || {}, options));

        case 7:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * increment field data
   * @param  {String} field []
   * @param  {Number} step  []
   * @return {Promise}       []
   */

  _default.prototype.increment = function increment(field) {
    var _$inc;

    var step = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
    var options;
    return _regeneratorRuntime.async(function increment$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.parseOptions(options));

        case 2:
          options = context$2$0.sent;
          return context$2$0.abrupt('return', this.db().update({
            $inc: (_$inc = {}, _$inc[field] = step, _$inc)
          }, options).then(function (data) {
            return data.result.n;
          }));

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * decrement field data
   * @param  {String} field []
   * @param  {Number} step  []
   * @return {Promise}       []
   */

  _default.prototype.decrement = function decrement(field) {
    var _$inc2;

    var step = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
    var options;
    return _regeneratorRuntime.async(function decrement$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.parseOptions(options));

        case 2:
          options = context$2$0.sent;
          return context$2$0.abrupt('return', this.db().update({
            $inc: (_$inc2 = {}, _$inc2[field] = 0 - step, _$inc2)
          }, options).then(function (data) {
            return data.result.n;
          }));

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * get count 
   * @param  {String} field []
   * @return {Promise}       []
   */

  _default.prototype.count = function count(field) {
    var options;
    return _regeneratorRuntime.async(function count$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          this.field(field);
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap(this.parseOptions());

        case 3:
          options = context$2$0.sent;
          return context$2$0.abrupt('return', this.db().count(options));

        case 5:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * get sum
   * @param  {String} field []
   * @return {Promise}       []
   */

  _default.prototype.sum = function sum(field) {
    var options;
    return _regeneratorRuntime.async(function sum$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          this.field(field);
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap(this.parseOptions());

        case 3:
          options = context$2$0.sent;
          return context$2$0.abrupt('return', this.db().sum(options));

        case 5:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * aggregate
   * http://docs.mongodb.org/manual/reference/sql-aggregation-comparison/
   * @param  {} options []
   * @return {}         []
   */

  _default.prototype.aggregate = function aggregate(options) {
    return this.db().aggregate(this.getTableName(), options);
  };

  /**
   * map reduce
   * Examples: http://docs.mongodb.org/manual/tutorial/map-reduce-examples/
   * @param  {Function} map    []
   * @param  {Function} reduce []
   * @param  {Object} out    []
   * @return {Promise}        []
   */

  _default.prototype.mapReduce = function mapReduce(map, reduce, out) {
    return this.collection().then(function (collection) {
      return collection.mapReduce(map, reduce, out);
    });
  };

  /**
   * create indexes
   * @param  {Object} indexes []
   * @return {Promise}         []
   */

  _default.prototype.createIndex = function createIndex(indexes, options) {
    return this.db().ensureIndex(this.getTableName(), indexes, options);
  };

  /**
   * get collection indexes
   * @return {Promise} []
   */

  _default.prototype.getIndexes = function getIndexes() {
    return this.collection().then(function (collection) {
      return collection.indexes();
    });
  };

  return _default;
})(_baseJs2['default']);

exports['default'] = _default;
module.exports = exports['default'];

//get count

//get page options