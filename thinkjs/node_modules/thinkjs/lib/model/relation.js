'use strict';

//model relation type

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

exports.__esModule = true;
think.model.HAS_ONE = 1;
think.model.BELONG_TO = 2;
think.model.HAS_MANY = 3;
think.model.MANY_TO_MANY = 4;
/**
 * relation model
 * @type {Class}
 */

var _default = (function (_think$model$base) {
  _inherits(_default, _think$model$base);

  function _default() {
    _classCallCheck(this, _default);

    _think$model$base.apply(this, arguments);
  }

  /**
   * init
   * @param  {String} name   []
   * @param  {Object} config []
   * @return {}        []
   */

  _default.prototype.init = function init() {
    var name = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
    var config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _think$model$base.prototype.init.call(this, name, config);
    /**
     * @example
     'profile': {
        type: think.model.HAS_ONE, //relation type
        model: 'profile', //model name
        name: 'profile', //data name
        key: 'id', 
        fKey: 'user_id', //forign key
        field: 'id,name',
        where: 'name=xx',
        order: '',
        limit: ''
      }
     */
    if (this.relation === undefined) {
      this.relation = {};
    }
    this._relationName = true;
  };

  /**
   * set relation
   * @param {String} name []
   */

  _default.prototype.setRelation = function setRelation(name, value) {
    //ignore undefined name
    if (name === undefined) {
      return this;
    }

    //config relation data
    if (think.isObject(name) || !think.isEmpty(value)) {
      var _ref;

      var obj = think.isObject(name) ? name : (_ref = {}, _ref[name] = value, _ref);
      think.extend(this.relation, obj);
      return this;
    }

    if (think.isBoolean(name)) {
      this._relationName = name;
      return this;
    }

    //enable relation
    if (think.isString(name)) {
      name = name.split(/\s*,\s*/);
    }

    name = name || [];
    //filter relation name
    if (value === false) {
      var filterRelations = _Object$keys(this.relation).filter(function (item) {
        return name.indexOf(item) === -1;
      });
      name = filterRelations;
    }

    this._relationName = name;
    return this;
  };

  /**
   * after find
   * @param  {Object} data []
   * @return {Promise}      []
   */

  _default.prototype.afterFind = function afterFind(data, options) {
    return this.getRelation(data, options);
  };

  /**
   * after select
   * @param  {Object} data []
   * @return {}      []
   */

  _default.prototype.afterSelect = function afterSelect(data, options) {
    return this.getRelation(data, options);
  };

  /**
   * get relation data
   * @param  {}  data       []
   * @param  Boolean isDataList 
   * @return {}
   */

  _default.prototype.getRelation = function getRelation(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var pk, promises;
    return _regeneratorRuntime.async(function getRelation$(context$2$0) {
      var _this = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (!(think.isEmpty(data) || think.isEmpty(this.relation) || think.isEmpty(this._relationName))) {
            context$2$0.next = 2;
            break;
          }

          return context$2$0.abrupt('return', data);

        case 2:
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(this.getPk());

        case 4:
          pk = context$2$0.sent;
          promises = _Object$keys(this.relation).map(function (key) {
            //relation is disabled
            if (_this._relationName !== true && _this._relationName.indexOf(key) === -1) {
              return;
            }
            var item = _this.relation[key];
            if (!think.isObject(item)) {
              item = { type: item };
            }
            //get relation model options
            var opts = think.extend({
              name: key,
              type: think.model.HAS_ONE,
              key: pk,
              fKey: _this.name + '_id',
              relation: true
            }, item);

            //relation data is exist
            var itemData = think.isArray(data) ? data[0] : data;
            var relData = itemData[opts.name];
            if (think.isArray(relData) || think.isObject(relData)) {
              return;
            }

            var modelOpts = think.extend({}, {
              cache: options.cache
            });
            //remove cache key
            if (modelOpts.cache && modelOpts.cache.key) {
              delete modelOpts.cache.key;
            }

            ['where', 'field', 'order', 'limit', 'page'].forEach(function (optItem) {
              if (think.isFunction(item[optItem])) {
                modelOpts[optItem] = item[optItem].call(_this);
              } else {
                modelOpts[optItem] = item[optItem];
              }
            });
            //get relation model instance
            var model = _this.model(item.model || key).options(modelOpts);

            //set relation to relate model
            if (model.setRelation) {
              model.setRelation(opts.relation, false);
            }

            opts.model = model;

            switch (item.type) {
              case think.model.BELONG_TO:
                return _this._getBelongsToRelation(data, opts, options);
              case think.model.HAS_MANY:
                return _this._getHasManyRelation(data, opts, options);
              case think.model.MANY_TO_MANY:
                return _this._getManyToManyRelation(data, opts, options);
              default:
                return _this._getHasOneRelation(data, opts, options);
            }
          });
          context$2$0.next = 8;
          return _regeneratorRuntime.awrap(_Promise.all(promises));

        case 8:
          return context$2$0.abrupt('return', data);

        case 9:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * has one
   * @param  {Object} data    []
   * @param  {Object} mapOpts []
   * @return {Promise}         []
   */

  _default.prototype._getHasOneRelation = function _getHasOneRelation(data, mapOpts /*, options*/) {
    var where, mapData;
    return _regeneratorRuntime.async(function _getHasOneRelation$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          where = this.parseRelationWhere(data, mapOpts);
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap(mapOpts.model.where(where).select());

        case 3:
          mapData = context$2$0.sent;
          return context$2$0.abrupt('return', this.parseRelationData(data, mapData, mapOpts));

        case 5:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * belongs to
   * @param  {Object} data    []
   * @param  {Object} mapOpts []
   * @return {Promise}         []
   */

  _default.prototype._getBelongsToRelation = function _getBelongsToRelation(data, mapOpts /*, options*/) {
    var where, mapData;
    return _regeneratorRuntime.async(function _getBelongsToRelation$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          mapOpts.key = mapOpts.model.getModelName() + '_id';
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap(mapOpts.model.getPk());

        case 3:
          mapOpts.fKey = context$2$0.sent;
          where = this.parseRelationWhere(data, mapOpts);
          context$2$0.next = 7;
          return _regeneratorRuntime.awrap(mapOpts.model.where(where).select());

        case 7:
          mapData = context$2$0.sent;
          return context$2$0.abrupt('return', this.parseRelationData(data, mapData, mapOpts));

        case 9:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * has many
   * @param  {Object} data    []
   * @param  {Object} mapOpts []
   * @return {Promise}         []
   */

  _default.prototype._getHasManyRelation = function _getHasManyRelation(data, mapOpts /*, options*/) {
    var where, mapData;
    return _regeneratorRuntime.async(function _getHasManyRelation$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          where = this.parseRelationWhere(data, mapOpts);
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap(mapOpts.model.where(where).select());

        case 3:
          mapData = context$2$0.sent;
          return context$2$0.abrupt('return', this.parseRelationData(data, mapData, mapOpts, true));

        case 5:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * many to many
   * @param  {Object} data    []
   * @param  {Object} mapOpts []
   * @param  {Object} options []
   * @return {Promise}         []
   */

  _default.prototype._getManyToManyRelation = function _getManyToManyRelation(data, mapOpts, options) {
    var where, sql, field, pk, table, table1, where1, rkey, where2, mapData;
    return _regeneratorRuntime.async(function _getManyToManyRelation$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          where = this.parseRelationWhere(data, mapOpts);
          sql = 'SELECT %s, a.%s FROM %s as a, %s as b %s AND a.%s=b.%s %s';
          field = this.db().parseField(mapOpts.field).split(',').map(function (item) {
            return 'b.' + item;
          }).join(',');
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap(mapOpts.model.getPk());

        case 5:
          pk = context$2$0.sent;
          table = mapOpts.rModel;

          if (table) {
            if (this.tablePrefix && table.indexOf(this.tablePrefix) !== 0) {
              table = this.tablePrefix + table;
            }
          } else {
            table = this.getRelationTableName(mapOpts.model);
          }

          table1 = mapOpts.model.getTableName();
          where1 = this.db().parseWhere(where);
          rkey = mapOpts.rfKey || mapOpts.model.getModelName() + '_id';
          where2 = mapOpts.where ? ' AND ' + this.db().parseWhere(mapOpts.where).trim().slice(6) : '';

          sql = this.parseSql(sql, field, mapOpts.fKey, table, table1, where1, rkey, pk, where2);
          context$2$0.next = 15;
          return _regeneratorRuntime.awrap(this.db().select(sql, options.cache));

        case 15:
          mapData = context$2$0.sent;
          return context$2$0.abrupt('return', this.parseRelationData(data, mapData, mapOpts, true));

        case 17:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * get relation table name
   * @param  {Object} model []
   * @return {}       []
   */

  _default.prototype.getRelationTableName = function getRelationTableName(model) {
    var table = [this.tablePrefix, this.tableName || this.name, '_', model.getModelName()].join('');
    return table.toLowerCase();
  };

  /**
   * get relation model
   * @param  {} model []
   * @return {}       []
   */

  _default.prototype.getRelationModel = function getRelationModel(model) {
    var name = (this.tableName || this.name) + '_' + model.getModelName();
    return this.model(name);
  };

  /**
   * parese relation where
   * @param  {Object} data    []
   * @param  {Object} mapOpts []
   * @return {}         []
   */

  _default.prototype.parseRelationWhere = function parseRelationWhere(data, mapOpts) {
    var _ref3;

    if (think.isArray(data)) {
      var _ref2;

      var _ret = (function () {
        var keys = {};
        data.forEach(function (item) {
          keys[item[mapOpts.key]] = 1;
        });
        var value = _Object$keys(keys);
        return {
          v: (_ref2 = {}, _ref2[mapOpts.fKey] = ['IN', value], _ref2)
        };
      })();

      if (typeof _ret === 'object') return _ret.v;
    }
    return _ref3 = {}, _ref3[mapOpts.fKey] = data[mapOpts.key], _ref3;
  };

  /**
   * parse relation data
   * @param  {Object}  data     []
   * @param  {}  mapData  []
   * @param  {}  mapOpts  []
   * @param  {Boolean} isArrMap []
   * @return {}           []
   */

  _default.prototype.parseRelationData = function parseRelationData(data, mapData, mapOpts, isArrMap) {
    if (think.isArray(data)) {
      data.forEach(function (item, i) {
        data[i][mapOpts.name] = isArrMap ? [] : {};
      });
      mapData.forEach(function (mapItem) {
        data.forEach(function (item, i) {
          if (mapItem[mapOpts.fKey] !== item[mapOpts.key]) {
            return;
          }
          if (isArrMap) {
            data[i][mapOpts.name].push(mapItem);
          } else {
            data[i][mapOpts.name] = mapItem;
          }
        });
      });
    } else {
      data[mapOpts.name] = isArrMap ? mapData : mapData[0] || {};
    }
    return data;
  };

  /**
   * after add
   * @param  {} data          []
   * @param  {} parsedOptions []
   * @return {}               []
   */

  _default.prototype.afterAdd = function afterAdd(data, options) {
    return this.postRelation('ADD', data, options);
  };

  /**
   * after delete
   * @param  {} data          []
   * @param  {} parsedOptions []
   * @return {}               []
   */

  _default.prototype.afterDelete = function afterDelete(data, options) {
    return this.postRelation('DELETE', data, options);
  };

  /**
   * after update
   * @param  {} data          []
   * @param  {} parsedOptions []
   * @return {}               []
   */

  _default.prototype.afterUpdate = function afterUpdate(data, options) {
    return this.postRelation('UPDATE', data, options);
  };

  /**
   * post relation
   * @param  {} postType      []
   * @param  {} data          []
   * @param  {} parsedOptions []
   * @return {}               []
   */

  _default.prototype.postRelation = function postRelation(postType, data /*, parsedOptions*/) {
    var pk, promises;
    return _regeneratorRuntime.async(function postRelation$(context$2$0) {
      var _this2 = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (!(think.isEmpty(data) || think.isEmpty(this.relation) || think.isEmpty(this._relationName))) {
            context$2$0.next = 2;
            break;
          }

          return context$2$0.abrupt('return', data);

        case 2:
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(this.getPk());

        case 4:
          pk = context$2$0.sent;
          promises = _Object$keys(this.relation).map(function (key) {
            var item = _this2.relation[key];
            if (!think.isObject(item)) {
              item = { type: item };
            }
            var opts = think.extend({
              type: think.model.HAS_ONE,
              postType: postType,
              name: key,
              key: pk,
              fKey: _this2.name + '_id'
            }, item);
            if (_this2._relationName !== true && _this2._relationName.indexOf(opts.name) === -1) {
              return;
            }
            var mapData = data[opts.name];
            if (think.isEmpty(mapData) && postType !== 'DELETE' || think.isEmpty(data[opts.key])) {
              return;
            }
            opts.data = mapData;
            opts.model = _this2.model(item.model || key).where(item.where);
            switch (item.type) {
              case think.model.BELONG_TO:
                return _this2._postBelongsToRelation(data, opts);
              case think.model.HAS_MANY:
                return _this2._postHasManyRelation(data, opts);
              case think.model.MANY_TO_MANY:
                return _this2._postManyToManyRelation(data, opts);
              default:
                return _this2._postHasOneRelation(data, opts);
            }
          });
          context$2$0.next = 8;
          return _regeneratorRuntime.awrap(_Promise.all(promises));

        case 8:
          return context$2$0.abrupt('return', data);

        case 9:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * has one post
   * @param  {} data          []
   * @param  {} value         []
   * @param  {} mapOptions    []
   * @param  {} parsedOptions []
   * @return {}               []
   */

  _default.prototype._postHasOneRelation = function _postHasOneRelation(data, mapOpts) {
    var _where, _where2;

    var where = undefined;
    switch (mapOpts.postType) {
      case 'ADD':
        mapOpts.data[mapOpts.fKey] = data[mapOpts.key];
        return mapOpts.model.add(mapOpts.data);
      case 'DELETE':
        where = (_where = {}, _where[mapOpts.fKey] = data[mapOpts.key], _where);
        return mapOpts.model.where(where)['delete']();
      case 'UPDATE':
        where = (_where2 = {}, _where2[mapOpts.fKey] = data[mapOpts.key], _where2);
        return mapOpts.model.where(where).update(mapOpts.data);
    }
  };

  /**
   * belongs to
   * @param  {} data []
   * @return {}      []
   */

  _default.prototype._postBelongsToRelation = function _postBelongsToRelation(data) {
    return data;
  };

  /**
   * has many
   * @param  {} data          []
   * @param  {} value         []
   * @param  {} mapOptions    []
   * @param  {} parsedOptions []
   * @return {}               []
   */

  _default.prototype._postHasManyRelation = function _postHasManyRelation(data, mapOpts) {
    var _where3;

    var mapData = mapOpts.data;
    var model = mapOpts.model;
    if (!think.isArray(mapData)) {
      mapData = [mapData];
    }
    switch (mapOpts.postType) {
      case 'ADD':
        mapData = mapData.map(function (item) {
          item[mapOpts.fKey] = data[mapOpts.key];
          return item;
        });
        return model.addMany(mapData);
      case 'UPDATE':
        return model.getTableFields().then(function () {
          var pk = model.getPk();
          var promises = mapData.map(function (item) {
            if (item[pk]) {
              return model.update(item);
            } else {
              item[mapOpts.fKey] = data[mapOpts.key];
              //ignore error when add data
              return model.add(item)['catch'](function () {});
            }
          });
          return _Promise.all(promises);
        });
      case 'DELETE':
        var where = (_where3 = {}, _where3[mapOpts.fKey] = data[mapOpts.key], _where3);
        return model.where(where)['delete']();
    }
  };

  /**
   * many to many post
   * @param  Object data          []
   * @param  object value         []
   * @param  {} mapOptions    []
   * @param  {} parsedOptions []
   * @return {}               []
   */

  _default.prototype._postManyToManyRelation = function _postManyToManyRelation(data, mapOpts) {
    var model, rfKey, relationModel, type, _where4, where, mapData, firstItem, postData, unqiueField, ids;

    return _regeneratorRuntime.async(function _postManyToManyRelation$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          model = mapOpts.model;
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap(model.getTableFields());

        case 3:
          rfKey = mapOpts.rfKey || model.getModelName().toLowerCase() + '_id';
          relationModel = this.getRelationModel(model);
          type = mapOpts.postType;

          if (!(type === 'DELETE' || type === 'UPDATE')) {
            context$2$0.next = 10;
            break;
          }

          where = (_where4 = {}, _where4[mapOpts.fKey] = data[mapOpts.key], _where4);
          context$2$0.next = 10;
          return _regeneratorRuntime.awrap(relationModel.where(where)['delete']());

        case 10:
          if (!(type === 'ADD' || type === 'UPDATE')) {
            context$2$0.next = 31;
            break;
          }

          mapData = mapOpts.data;

          if (!think.isArray(mapData)) {
            mapData = think.isString(mapData) ? mapData.split(',') : [mapData];
          }
          firstItem = mapData[0];

          if (!(think.isNumberString(firstItem) || think.isObject(firstItem) && rfKey in firstItem)) {
            context$2$0.next = 20;
            break;
          }

          postData = mapData.map(function (item) {
            var _ref4;

            return _ref4 = {}, _ref4[mapOpts.fKey] = data[mapOpts.key], _ref4[rfKey] = item[rfKey] || item, _ref4;
          });
          context$2$0.next = 18;
          return _regeneratorRuntime.awrap(relationModel.addMany(postData));

        case 18:
          context$2$0.next = 31;
          break;

        case 20:
          context$2$0.next = 22;
          return _regeneratorRuntime.awrap(model.getUniqueField());

        case 22:
          unqiueField = context$2$0.sent;

          if (unqiueField) {
            context$2$0.next = 25;
            break;
          }

          return context$2$0.abrupt('return', think.reject(new Error('table `' + model.getTableName() + '` has no unqiue field')));

        case 25:
          context$2$0.next = 27;
          return _regeneratorRuntime.awrap(this._getRalationAddIds(mapData, model, unqiueField));

        case 27:
          ids = context$2$0.sent;
          postData = ids.map(function (id) {
            var _ref5;

            return _ref5 = {}, _ref5[mapOpts.fKey] = data[mapOpts.key], _ref5[rfKey] = id, _ref5;
          });
          context$2$0.next = 31;
          return _regeneratorRuntime.awrap(relationModel.addMany(postData));

        case 31:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * insert data, add ids
   * @param  {Array} dataList    []
   * @param  {Object} model       []
   * @param  {String} unqiueField []
   * @return {Promise}             []
   */

  _default.prototype._getRalationAddIds = function _getRalationAddIds(dataList, model, unqiueField) {
    var ids, pk, promises;
    return _regeneratorRuntime.async(function _getRalationAddIds$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          ids = [];
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap(model.getPk());

        case 3:
          pk = context$2$0.sent;
          promises = dataList.map(function (item) {
            var _where5;

            if (!think.isObject(item)) {
              var _item;

              item = (_item = {}, _item[unqiueField] = item, _item);
            }
            var value = item[unqiueField];
            var where = (_where5 = {}, _where5[unqiueField] = value, _where5);
            return model.where(where).field(pk).find().then(function (data) {
              if (think.isEmpty(data)) {
                return model.add(item).then(function (insertId) {
                  ids.push(insertId);
                });
              } else {
                ids.push(data[pk]);
              }
            });
          });
          context$2$0.next = 7;
          return _regeneratorRuntime.awrap(_Promise.all(promises));

        case 7:
          return context$2$0.abrupt('return', ids);

        case 8:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  return _default;
})(think.model.base);

exports['default'] = _default;
module.exports = exports['default'];

// if (where === false) {
//   return {};
// }

// if (where === false) {
//   return [];
// }