'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _baseJs = require('./base.js');

var _baseJs2 = _interopRequireDefault(_baseJs);

/**
 * websocket adapter for sockjs
 */

var _default = (function (_Base) {
  _inherits(_default, _Base);

  function _default() {
    _classCallCheck(this, _default);

    _Base.apply(this, arguments);
  }

  /**
   * run
   * @return {} []
   */

  _default.prototype.run = function run() {
    var sockjs, options, sockjsServer, messages, open, close, path;
    return _regeneratorRuntime.async(function run$(context$2$0) {
      var _this = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(think.npm('sockjs'));

        case 2:
          sockjs = context$2$0.sent;
          options = {
            log: function log() {}
          };

          if (this.config.sockjs_url) {
            options.sockjs_url = this.config.sockjs_url;
          }
          sockjsServer = sockjs.createServer(options);

          this.sockjs = sockjsServer;

          //get message type
          messages = think.extend({}, this.config.messages);
          open = messages.open;

          delete messages.open;
          close = messages.close;

          delete messages.close;

          thinkCache(thinkCache.WEBSOCKET, []);

          sockjsServer.on('connection', function (socket) {

            _this.addSocket(socket);

            //open connection
            if (open) {
              _this.message(open, undefined, socket);
            }

            socket.on('close', function () {
              _this.removeSocket(socket);

              if (close) {
                _this.message(close, undefined, socket);
              }
            });

            //msg is {event: event, data: data}
            socket.on('data', function (msg) {
              try {
                msg = JSON.parse(msg);
                if (msg.event && messages[msg.event]) {
                  _this.message(messages[msg.event], msg.data, socket);
                }
              } catch (e) {}
            });
          });

          path = this.config.path || '/sockjs';

          sockjsServer.installHandlers(this.server, { prefix: path });

        case 16:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * add socket
   * @param {Object} socket []
   */

  _default.prototype.addSocket = function addSocket(socket) {
    var sockets = thinkCache(thinkCache.WEBSOCKET);
    sockets.push(socket);
  };

  /**
   * remove socket
   * @param  {Object} socket []
   * @return {}        []
   */

  _default.prototype.removeSocket = function removeSocket(socket) {
    var sockets = thinkCache(thinkCache.WEBSOCKET);
    sockets.some(function (item, index) {
      if (item.id === socket.id) {
        sockets.splice(index, 1);
        return true;
      }
    });
  };

  /**
   * emit data
   * @param  {String} event []
   * @param  {Mixed} data  []
   * @return {}       []
   */

  _default.prototype.emit = function emit(event, data) {
    this.socket.write(JSON.stringify({ event: event, data: data }));
  };

  /**
   * broadcast data
   * @param  {String} event []
   * @param  {Mixed} data  []
   * @return {}       []
   */

  _default.prototype.broadcast = function broadcast(event, data, containSelf) {
    var _this2 = this;

    var sockets = thinkCache(thinkCache.WEBSOCKET);
    sockets.forEach(function (socket) {
      if (!containSelf && socket.id === _this2.socket.id) {
        return;
      }
      socket.write(JSON.stringify({ event: event, data: data }));
    });
  };

  /**
   * deal message
   * @param  {String} url  []
   * @param  {Mixed} data []
   * @return {}      []
   */

  _default.prototype.message = function message(url, data, socket) {
    var http, instance;
    return _regeneratorRuntime.async(function message$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (url[0] !== '/') {
            url = '/' + url;
          }

          context$2$0.next = 3;
          return _regeneratorRuntime.awrap(think.http({
            url: url,
            headers: socket.headers,
            ip: socket.remoteAddress
          }));

        case 3:
          http = context$2$0.sent;

          http.data = data;
          http.socket = socket;
          http.sockjs = this.sockjs;

          http.socketEmit = this.emit;
          http.socketBroadcast = this.broadcast;

          instance = new this.app(http);
          return context$2$0.abrupt('return', instance.run());

        case 11:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  return _default;
})(_baseJs2['default']);

exports['default'] = _default;
module.exports = exports['default'];