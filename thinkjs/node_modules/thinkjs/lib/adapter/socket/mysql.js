'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _baseJs = require('./base.js');

var _baseJs2 = _interopRequireDefault(_baseJs);

/**
 * mysql socket class
 * @return {} []
 */

var _default = (function (_Base) {
  _inherits(_default, _Base);

  function _default() {
    _classCallCheck(this, _default);

    _Base.apply(this, arguments);
  }

  /**
   * init
   * @param  {Object} config [connection options]
   * @return {}        []
   */

  _default.prototype.init = function init() {
    var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _Base.prototype.init.call(this, config);
    //alias password config
    if (config.pwd) {
      config.password = config.pwd;
      delete config.pwd;
    }
    if (config.name) {
      config.database = config.name;
      delete config.name;
    }
    //merge config
    this.config = think.extend({
      host: '127.0.0.1',
      user: 'root',
      password: ''
    }, config);
    this.config.port = this.config.port || 3306;

    this.pool = null;
  };

  /**
   * get connection
   * @return {Promise} [conneciton handle]
   */

  _default.prototype.getConnection = function getConnection() {
    var config, str, mysql;
    return _regeneratorRuntime.async(function getConnection$(context$2$0) {
      var _this = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (!this.connection) {
            context$2$0.next = 2;
            break;
          }

          return context$2$0.abrupt('return', this.connection);

        case 2:
          config = this.config;
          str = 'mysql://' + config.user + ':' + config.password + '@' + config.host + ':' + config.port;

          if (!this.pool) {
            context$2$0.next = 6;
            break;
          }

          return context$2$0.abrupt('return', think.await(str, function () {
            var fn = think.promisify(_this.pool.getConnection, _this.pool);
            var promise = fn()['catch'](function (err) {
              _this.close();
              return _Promise.reject(err);
            });
            var err = new Error(str);
            return think.error(promise, err);
          }));

        case 6:
          context$2$0.next = 8;
          return _regeneratorRuntime.awrap(think.npm('mysql'));

        case 8:
          mysql = context$2$0.sent;

          if (!config.connectionLimit) {
            context$2$0.next = 13;
            break;
          }

          this.logConnect(str, 'mysql');

          this.pool = mysql.createPool(config);
          return context$2$0.abrupt('return', this.getConnection());

        case 13:
          return context$2$0.abrupt('return', think.await(str, function () {
            var deferred = think.defer();
            _this.connection = mysql.createConnection(config);
            _this.connection.connect(function (err) {

              _this.logConnect(str, 'mysql');

              if (err) {
                deferred.reject(err);
                _this.close();
              } else {
                deferred.resolve(_this.connection);
              }
            });
            _this.connection.on('error', function () {
              _this.close();
            });
            //PROTOCOL_CONNECTION_LOST
            _this.connection.on('end', function () {
              _this.connection = null;
            });
            var err = new Error(str);
            return think.error(deferred.promise, err);
          }));

        case 14:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * query sql
   * @param  {String} sql []
   * @return {[type]}     []
   */

  _default.prototype.query = function query(sql, nestTables) {
    var connection, data, startTime, fn, promise;
    return _regeneratorRuntime.async(function query$(context$2$0) {
      var _this2 = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.getConnection());

        case 2:
          connection = context$2$0.sent;
          data = {
            sql: sql,
            nestTables: nestTables
          };

          //query timeout
          if (this.config.timeout) {
            data.timeout = this.config.timeout;
          }
          startTime = Date.now();
          fn = think.promisify(connection.query, connection);
          promise = fn(data).then(function () {
            var rows = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

            // just call connection.release() and the connection will return to the pool,
            // ready to be used again by someone else.
            // https://github.com/felixge/node-mysql#pooling-connections
            if (_this2.pool && connection.release) {
              connection.release();
            }

            if (_this2.config.log_sql) {
              think.log(sql, 'SQL', startTime);
            }
            return rows;
          })['catch'](function (err) {
            if (_this2.pool && connection.release) {
              connection.release();
            }
            //Connection lost: The server closed the connection.
            if (err.code === 'PROTOCOL_CONNECTION_LOST') {
              _this2.close();
            }

            if (_this2.config.log_sql) {
              think.log(sql, 'SQL', startTime);
            }
            return _Promise.reject(err);
          });

          promise = this.autoClose(promise);
          return context$2$0.abrupt('return', think.error(promise));

        case 10:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * execute
   * @param  {Array} args []
   * @return {Promise}         []
   */

  _default.prototype.execute = function execute() {
    return this.query.apply(this, arguments);
  };

  /**
   * close connections
   * @return {} []
   */

  _default.prototype.close = function close() {
    var _this3 = this;

    if (this.pool) {
      this.pool.end(function () {
        return _this3.pool = null;
      });
    } else if (this.connection) {
      this.connection.end(function () {
        return _this3.connection = null;
      });
    }
  };

  return _default;
})(_baseJs2['default']);

exports['default'] = _default;
module.exports = exports['default'];