'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _baseJs = require('./base.js');

var _baseJs2 = _interopRequireDefault(_baseJs);

/**
 * memcache socket
 */

var _default = (function (_Base) {
  _inherits(_default, _Base);

  function _default() {
    _classCallCheck(this, _default);

    _Base.apply(this, arguments);
  }

  /**
   * inti
   * @param  {Object} config []
   * @return {}        []
   */

  _default.prototype.init = function init() {
    var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _Base.prototype.init.call(this, config);

    this.config = think.extend({
      host: '127.0.0.1',
      port: 11211,
      username: '',
      password: ''
    }, config);
  };

  /**
   * get socket connect str
   * @return {String} []
   */

  _default.prototype.getSocketStr = function getSocketStr(protocal) {
    var str = '';
    var config = this.config;
    if (config.username) {
      str += config.username;
    }
    if (config.password) {
      str += ':' + config.password;
    }
    if (str) {
      str += '@';
    }
    str += config.host + ':' + config.port;
    if (protocal) {
      return 'memcache://' + str;
    }
    return str;
  };

  /**
   * get connection
   * @return {Promise} []
   */

  _default.prototype.getConnection = function getConnection() {
    var memjs;
    return _regeneratorRuntime.async(function getConnection$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (!this.connection) {
            context$2$0.next = 2;
            break;
          }

          return context$2$0.abrupt('return', this.connection);

        case 2:
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(think.npm('memjs'));

        case 4:
          memjs = context$2$0.sent;

          this.connection = memjs.Client.create(this.getSocketStr(), {
            logger: {
              log: function log() {}
            }
          });

          this.logConnect(this.getSocketStr(true), 'memcache');

          return context$2$0.abrupt('return', this.connection);

        case 8:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * wrap method
   * @param  {String}    name []
   * @param  {} args []
   * @return {Promise}         []
   */

  _default.prototype.wrap = function wrap(name) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var connection, deferred, callback, err;
    return _regeneratorRuntime.async(function wrap$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.getConnection());

        case 2:
          connection = context$2$0.sent;
          deferred = think.defer();

          callback = function callback(err, data) {
            return err ? deferred.reject(err) : deferred.resolve(data && data.toString());
          };

          if (args.length === 1) {
            args.push(callback);
          } else {
            args = [args[0], args[1], callback, args[2]];
          }
          connection[name].apply(connection, args);
          err = new Error(this.getSocketStr(true));
          return context$2$0.abrupt('return', think.error(deferred.promise, err));

        case 9:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * get data
   * @param  {String} key []
   * @return {Promise}     []
   */

  _default.prototype.get = function get(key) {
    return this.wrap('get', key);
  };

  /**
   * set data 
   * @param {String} key     []
   * @param {String} value   []
   * @param {Number} timeout []
   */

  _default.prototype.set = function set(key, value) {
    var timeout = arguments.length <= 2 || arguments[2] === undefined ? this.config.timeout : arguments[2];

    return this.wrap('set', key, value, timeout);
  };

  /**
   * delete data
   * @param  {String} key []
   * @return {Promise}     []
   */

  _default.prototype['delete'] = function _delete(key) {
    return this.wrap('delete', key);
  };

  /**
   * increment
   * @param  {String} key     []
   * @param  {Number} amount  []
   * @param  {Number} timeout []
   * @return {Promise}         []
   */

  _default.prototype.increment = function increment(key, amount) {
    var timeout = arguments.length <= 2 || arguments[2] === undefined ? this.config.timeout : arguments[2];

    return this.wrap('increment', key, amount, timeout);
  };

  /**
   * decrement
   * @param  {String} key     []
   * @param  {Number} amount  []
   * @param  {Number} timeout []
   * @return {Promise}         []
   */

  _default.prototype.decrement = function decrement(key, amount) {
    var timeout = arguments.length <= 2 || arguments[2] === undefined ? this.config.timeout : arguments[2];

    return this.wrap('decrement', key, amount, timeout);
  };

  return _default;
})(_baseJs2['default']);

exports['default'] = _default;
module.exports = exports['default'];