'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _baseJs = require('./base.js');

var _baseJs2 = _interopRequireDefault(_baseJs);

/**
 * Redis socket class
 */

var _default = (function (_Base) {
  _inherits(_default, _Base);

  function _default() {
    _classCallCheck(this, _default);

    _Base.apply(this, arguments);
  }

  /**
   * init
   * @param  {Object} config []
   * @return {}        []
   */

  _default.prototype.init = function init() {
    var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _Base.prototype.init.call(this, config);

    this.config = think.extend({
      port: 6379,
      host: '127.0.0.1',
      password: ''
    }, config);
  };

  /**
   * connect redis
   * @return {Promise} []
   */

  _default.prototype.getConnection = function getConnection() {
    var redis, config, str;
    return _regeneratorRuntime.async(function getConnection$(context$2$0) {
      var _this = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (!this.connection) {
            context$2$0.next = 2;
            break;
          }

          return context$2$0.abrupt('return', this.connection);

        case 2:
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(think.npm('redis'));

        case 4:
          redis = context$2$0.sent;
          config = this.config;
          str = 'redis://' + config.host + ':' + config.port;
          return context$2$0.abrupt('return', think.await(str, function () {

            var deferred = think.defer();
            var connection = redis.createClient(config.port, config.host, config);
            if (config.password) {
              connection.auth(config.password, function () {});
            }
            connection.on('connect', function () {
              _this.connection = connection;
              _this.logConnect(str, 'redis');
              deferred.resolve(connection);
            });
            connection.on('error', function (err) {
              _this.close();
              _this.logConnect(str, 'redis');
              deferred.reject(err);
            });
            var err = new Error(str);
            return think.error(deferred.promise, err);
          }));

        case 8:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * add event
   * @param  {String}   event    []
   * @param  {Function} callback []
   * @return {}            []
   */

  _default.prototype.on = function on(event, callback) {
    return this.getConnection().then(function (connection) {
      connection.on(event, callback);
    });
  };

  /**
   * wrap
   * @param  {String}    name []
   * @param  {Array} data []
   * @return {Promise}         []
   */

  _default.prototype.wrap = function wrap(name) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    var fn;
    return _regeneratorRuntime.async(function wrap$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.getConnection());

        case 2:
          fn = think.promisify(this.connection[name], this.connection);
          return context$2$0.abrupt('return', think.error(fn.apply(undefined, data)));

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * get data
   * @param  {String} name []
   * @return {Promise}      []
   */

  _default.prototype.get = function get(name) {
    return this.wrap('get', name);
  };

  /**
   * set data
   * @param {String} name    []
   * @param {String} value   []
   * @param {Number} timeout []
   */

  _default.prototype.set = function set(name, value) {
    var timeout = arguments.length <= 2 || arguments[2] === undefined ? this.config.timeout : arguments[2];

    var setP = [this.wrap('set', name, value)];
    if (timeout) {
      setP.push(this.expire(name, timeout));
    }
    return _Promise.all(setP);
  };

  /**
   * set data expire
   * @param  {String} name    []
   * @param  {Number} timeout []
   * @return {Promise}         []
   */

  _default.prototype.expire = function expire(name, timeout) {
    return this.wrap('expire', name, timeout);
  };

  /**
   * delete data
   * @param  {String} name []
   * @return {Promise}      []
   */

  _default.prototype['delete'] = function _delete(name) {
    return this.wrap('del', name);
  };

  /**
   * close socket connection
   * @return {} []
   */

  _default.prototype.close = function close() {
    if (this.connection) {
      this.connection.end();
      this.connection = null;
    }
  };

  return _default;
})(_baseJs2['default']);

exports['default'] = _default;
module.exports = exports['default'];