'use strict';

/**
 * socket base class
 */

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

exports.__esModule = true;

var _default = (function (_think$adapter$base) {
  _inherits(_default, _think$adapter$base);

  function _default() {
    _classCallCheck(this, _default);

    _think$adapter$base.apply(this, arguments);
  }

  /**
   * init
   * @return {} []
   */

  _default.prototype.init = function init() {
    this.connection = null;
    //query queue nums
    this.queueNums = 0;
    //auto close socket timer
    this.closeTimer = 0;
  };

  /**
   * log connection
   * @return {} []
   */

  _default.prototype.logConnect = function logConnect(str, type) {
    //log mongodb connection infomation
    if (this.config.log_connect) {
      think.log(function (colors) {
        return 'Connect ' + type + ' with ' + colors.magenta(str);
      }, 'SOCKET');
    }
  };

  /**
   * auto close socket on cli mode
   * @return {Promise} []
   */

  _default.prototype.autoClose = function autoClose(promise) {
    var _this = this;

    if (!think.config('auto_close_socket')) {
      return promise;
    }

    var close = function close() {
      _this.queueNums--;
      if (_this.queueNums === 0) {
        _this.closeTimer = setTimeout(function () {
          _this.close();
        }, 3000);
      }
    };

    clearTimeout(this.closeTimer);

    this.queueNums++;
    return promise.then(function (data) {
      close();
      return data;
    })['catch'](function (err) {
      close();
      return _Promise.reject(err);
    });
  };

  /**
   * close socket connection
   * @return {} []
   */

  _default.prototype.close = function close() {
    if (this.connection) {
      this.connection.close();
      this.connection = null;
    }
  };

  /**
   * get instance
   * @param  {Object} config []
   * @return {Object}        []
   */

  _default.getInstance = function getInstance(config, type) {
    var extraKeys = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

    config = think.parseConfig(config);

    //delete extra keys when caculate config md5 value
    extraKeys.forEach(function (item) {
      return delete config[item];
    });
    var key = think.md5(JSON.stringify(config)).slice(0, 5);

    var instance = thinkCache(type, key);
    if (!instance) {
      instance = new this(config);
      thinkCache(type, key, instance);
    }
    return instance;
  };

  return _default;
})(think.adapter.base);

exports['default'] = _default;
module.exports = exports['default'];