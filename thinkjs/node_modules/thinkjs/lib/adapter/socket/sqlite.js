'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _baseJs = require('./base.js');

var _baseJs2 = _interopRequireDefault(_baseJs);

/**
 * sqlite socket
 */

var _default = (function (_Base) {
  _inherits(_default, _Base);

  function _default() {
    _classCallCheck(this, _default);

    _Base.apply(this, arguments);
  }

  /**
   * init
   * @param  {Object} config []
   * @return {}        []
   */

  _default.prototype.init = function init() {
    var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _Base.prototype.init.call(this, config);

    if (config.path === true) {
      config.path = ':memory:';
    } else {
      config.path = config.path || think.getPath(undefined, think.dirname.runtime) + '/sqlite';
      think.mkdir(config.path);
      config.path += '/' + config.name + '.sqlite';
    }
    this.config = config;
  };

  /**
   * get connection
   * @return {Promise} []
   */

  _default.prototype.getConnection = function getConnection() {
    var sqlite;
    return _regeneratorRuntime.async(function getConnection$(context$2$0) {
      var _this = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (!this.connection) {
            context$2$0.next = 2;
            break;
          }

          return context$2$0.abrupt('return', this.connection);

        case 2:
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(think.npm('sqlite3'));

        case 4:
          sqlite = context$2$0.sent;

          if (this.config.verbose) {
            sqlite = sqlite.verbose();
          }
          return context$2$0.abrupt('return', think.await(this.config.path, function () {
            var deferred = think.defer();
            var db = new sqlite.Database(_this.config.path, function (err) {
              _this.logConnect('sqlite://' + _this.config.path, 'sqlite');

              if (err) {
                deferred.reject(err);
              } else {
                _this.connection = db;
                deferred.resolve(db);
              }
            });
            //set timeout
            if (_this.config.timeout) {
              db.configure('busyTimeout', _this.config.timeout * 1000);
            }
            var err = new Error('sqlite://' + _this.config.path);
            return think.error(deferred.promise, err);
          }));

        case 7:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * query sql
   * @param  {String} sql []
   * @return {Promise}     []
   */

  _default.prototype.execute = function execute(sql) {
    var connection, deferred, startTime, logSql;
    return _regeneratorRuntime.async(function execute$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.getConnection());

        case 2:
          connection = context$2$0.sent;
          deferred = think.defer();
          startTime = Date.now();
          logSql = this.config.log_sql;

          //can not use arrow functions in here
          connection.run(sql, function (err) {
            if (logSql) {
              think.log(sql, 'SQL', startTime);
            }
            if (err) {
              deferred.reject(err);
            } else {
              deferred.resolve({
                insertId: this.lastID,
                affectedRows: this.changes
              });
            }
          });
          return context$2$0.abrupt('return', think.error(deferred.promise));

        case 8:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * execute sql
   * @param  {String} sql []
   * @return {Promise}     []
   */

  _default.prototype.query = function query(sql) {
    var connection, startTime, fn, promise;
    return _regeneratorRuntime.async(function query$(context$2$0) {
      var _this2 = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.getConnection());

        case 2:
          connection = context$2$0.sent;
          startTime = Date.now();
          fn = think.promisify(connection.all, connection);
          promise = fn(sql).then(function (data) {
            if (_this2.config.log_sql) {
              think.log(sql, 'SQL', startTime);
            }
            return data;
          })['catch'](function (err) {
            if (_this2.config.log_sql) {
              think.log(sql, 'SQL', startTime);
            }
            return _Promise.reject(err);
          });
          return context$2$0.abrupt('return', think.error(promise));

        case 7:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  return _default;
})(_baseJs2['default']);

exports['default'] = _default;
module.exports = exports['default'];