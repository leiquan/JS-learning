'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _baseJs = require('./base.js');

var _baseJs2 = _interopRequireDefault(_baseJs);

var SqliteSocket = think.adapter('socket', 'sqlite');
/**
 * sqlite db
 */

var _default = (function (_Base) {
  _inherits(_default, _Base);

  function _default() {
    _classCallCheck(this, _default);

    _Base.apply(this, arguments);
  }

  /**
   * get sqlite socket instance
   * @param  {Object} config []
   * @return {}        []
   */

  _default.prototype.socket = function socket(sql) {
    if (this._socket) {
      return this._socket;
    }
    var config = think.extend({
      sql: sql
    }, this.config);
    this._socket = SqliteSocket.getInstance(config, thinkCache.DB, ['sql']);
    return this._socket;
  };

  /**
   * get table info
   * @param  {String} table [table name]
   * @return {Promise}       []
   */

  _default.prototype.getFields = function getFields(table) {
    var fieldPromise, indexPromise, ret, _ref, data, indexes;

    return _regeneratorRuntime.async(function getFields$(context$2$0) {
      var _this2 = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          fieldPromise = this.query('PRAGMA table_info( ' + table + ' )');
          indexPromise = this.query('PRAGMA INDEX_LIST( ' + table + ' )').then(function callee$2$0(list) {
            var indexes, promises;
            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
              var _this = this;

              while (1) switch (context$3$0.prev = context$3$0.next) {
                case 0:
                  indexes = {};
                  promises = list.map(function callee$3$0(item) {
                    var _list;

                    return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                      while (1) switch (context$4$0.prev = context$4$0.next) {
                        case 0:
                          if (!item.unique) {
                            context$4$0.next = 5;
                            break;
                          }

                          context$4$0.next = 3;
                          return _regeneratorRuntime.awrap(this.query('PRAGMA index_info( ' + item.name + ' )'));

                        case 3:
                          _list = context$4$0.sent;

                          _list.forEach(function (item) {
                            indexes[item.name] = { unique: true };
                          });

                        case 5:
                        case 'end':
                          return context$4$0.stop();
                      }
                    }, null, _this);
                  });
                  context$3$0.next = 4;
                  return _regeneratorRuntime.awrap(_Promise.all(promises));

                case 4:
                  return context$3$0.abrupt('return', indexes);

                case 5:
                case 'end':
                  return context$3$0.stop();
              }
            }, null, _this2);
          });
          ret = {};
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap(_Promise.all([fieldPromise, indexPromise]));

        case 5:
          _ref = context$2$0.sent;
          data = _ref[0];
          indexes = _ref[1];

          data.forEach(function (item) {
            ret[item.name] = {
              name: item.name,
              type: item.type,
              required: !!item.notnull,
              'default': item.dflt_value,
              primary: !!item.pk,
              auto_increment: false,
              unique: !!(!item.pk && indexes[item.name] && indexes[item.name].unique)
            };
          });
          return context$2$0.abrupt('return', ret);

        case 10:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * escape string
   * @param  {String} str []
   * @return {String}     []
   */

  _default.prototype.escapeString = function escapeString(str) {
    return str.replace(/\'/g, '\'\'');
  };

  /**
   * parse limit
   * @param  {Array} limit []
   * @return {String}       []
   */

  _default.prototype.parseLimit = function parseLimit(limit) {
    if (think.isEmpty(limit)) {
      return '';
    }
    if (think.isNumber(limit)) {
      return ' LIMIT ' + limit;
    }
    if (think.isString(limit)) {
      limit = limit.split(/\s*,\s*/);
    }
    if (limit[1]) {
      return ' LIMIT ' + (limit[1] | 0) + ' OFFSET ' + (limit[0] | 0);
    }
    return ' LIMIT ' + (limit[0] | 0);
  };

  return _default;
})(_baseJs2['default']);

exports['default'] = _default;
module.exports = exports['default'];