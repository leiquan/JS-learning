'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _parse_mongoJs = require('./_parse_mongo.js');

var _parse_mongoJs2 = _interopRequireDefault(_parse_mongoJs);

var MongoSocket = think.adapter('socket', 'mongo');

/**
 * mongo db class
 */

var _default = (function (_Parse) {
  _inherits(_default, _Parse);

  function _default() {
    _classCallCheck(this, _default);

    _Parse.apply(this, arguments);
  }

  /**
   * init
   * @param  {Object} config []
   * @return {}        []
   */

  _default.prototype.init = function init(config) {
    _Parse.prototype.init.call(this);
    this.config = config;
    this.lastInsertId = 0;
    this._socket = null; //Mongo socket instance
  };

  /**
   * connect mongo socket
   * @return {Promise} []
   */

  _default.prototype.socket = function socket() {
    if (this._socket) {
      return this._socket;
    }
    this._socket = MongoSocket.getInstance(this.config, thinkCache.DB);
    return this._socket;
  };

  /**
   * get connection
   * @return {Promise} []
   */

  _default.prototype.collection = function collection(table) {
    var instance = this.socket();
    return instance.getConnection().then(function (db) {
      return db.collection(table);
    });
  };

  /**
   * get last insert id
   * @return {String} []
   */

  _default.prototype.getLastInsertId = function getLastInsertId() {
    return this.lastInsertId;
  };

  /**
   * add data
   * @param {Objec} data    []
   * @param {Object} options []
   */

  _default.prototype.add = function add(data, options) {
    var collection, result;
    return _regeneratorRuntime.async(function add$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.collection(options.table));

        case 2:
          collection = context$2$0.sent;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap(collection.insert(data));

        case 5:
          result = context$2$0.sent;

          this.lastInsertId = data._id;
          return context$2$0.abrupt('return', result);

        case 8:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * add multi data
   * @param {Array} dataList []
   * @param {Object} options [ {ordered: true}. If false, perform an unordered insert, and if an error occurs with one of documents, continue processing the remaining documents in the array.}]
   * @param {Object} options  []
   */

  _default.prototype.addMany = function addMany(dataList, options) {
    var collection, result, insertedIds;
    return _regeneratorRuntime.async(function addMany$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.collection(options.table));

        case 2:
          collection = context$2$0.sent;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap(collection.insert(dataList, options));

        case 5:
          result = context$2$0.sent;
          insertedIds = dataList.map(function (item) {
            return item._id;
          });

          this.lastInsertId = insertedIds;
          return context$2$0.abrupt('return', result);

        case 9:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * set collection limit
   * @param  {Object} collection []
   * @param  {String} limit      []
   * @return {Object}            []
   */

  _default.prototype.limit = function limit(collection, _limit) {
    _limit = this.parseLimit(_limit);
    if (_limit[0]) {
      collection.skip(_limit[0]);
    }
    if (_limit[1]) {
      collection.limit(_limit[1]);
    }
    return collection;
  };

  /**
   * parse group
   * @param  {String} group []
   * @return {Object}       []
   */

  _default.prototype.group = function group(_group) {
    _group = this.parseGroup(_group);
    var length = _group.length;
    if (length === 0) {
      return { _id: null };
    } else if (length === 1) {
      return { _id: '$' + _group[0] };
    } else {
      var _ret = (function () {
        var result = {};
        _group.forEach(function (item) {
          result[item] = '$' + item;
        });
        return {
          v: result
        };
      })();

      if (typeof _ret === 'object') return _ret.v;
    }
  };

  /**
   * select data
   * @param  {Object} options []
   * @return {Promise}         []
   */

  _default.prototype.select = function select(options) {
    var collection, where, distinct;
    return _regeneratorRuntime.async(function select$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.collection(options.table));

        case 2:
          collection = context$2$0.sent;
          where = this.parseWhere(options.where);
          distinct = this.parseDistinct(options.distinct);

          if (!distinct) {
            context$2$0.next = 7;
            break;
          }

          return context$2$0.abrupt('return', collection.distinct(distinct, where));

        case 7:

          collection = collection.find(where, this.parseField(options.field));
          collection = this.limit(collection, options.limit);
          collection = collection.sort(this.parseOrder(options.order));
          return context$2$0.abrupt('return', collection.toArray());

        case 11:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * update data
   * @param  {Object} data    []
   * @param  {Object} options []
   * @return {Promise}         []
   */

  _default.prototype.update = function update(data, options) {
    var collection, where, limit, flag, key;
    return _regeneratorRuntime.async(function update$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.collection(options.table));

        case 2:
          collection = context$2$0.sent;
          where = this.parseWhere(options.where);
          limit = this.parseLimit(options.limit);

          // updates multiple documents that meet the query criteria.
          // default only updates one document
          if (limit[1] !== 1) {
            options.multi = true;
          }

          // If set to true, creates a new document when no document matches the query criteria.
          // The default value is false, which does not insert a new document when no match is found.
          if (!options.upsert) {
            options.upsert = false;
          }

          //add $set for data
          flag = true;
          context$2$0.t0 = _regeneratorRuntime.keys(data);

        case 9:
          if ((context$2$0.t1 = context$2$0.t0()).done) {
            context$2$0.next = 16;
            break;
          }

          key = context$2$0.t1.value;

          if (!(key[0] !== '$')) {
            context$2$0.next = 14;
            break;
          }

          flag = false;
          return context$2$0.abrupt('break', 16);

        case 14:
          context$2$0.next = 9;
          break;

        case 16:
          if (!flag) {
            data = { $set: data };
          }

          // update operator
          // http://docs.mongodb.org/manual/reference/operator/update/#id1
          return context$2$0.abrupt('return', collection.update(where, data, options));

        case 18:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * delete data
   * @param  {Object} options []
   * @return {Promise}         []
   */

  _default.prototype['delete'] = function _delete(options) {
    var collection, where, limit, removeOpt;
    return _regeneratorRuntime.async(function _delete$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.collection(options.table));

        case 2:
          collection = context$2$0.sent;
          where = this.parseWhere(options.where);
          limit = this.parseLimit(options.limit);
          removeOpt = {};

          if (limit[1] === 1) {
            removeOpt.justOne = true;
          }

          return context$2$0.abrupt('return', collection.remove(where, removeOpt));

        case 8:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * get count
   * @param  {Object} options []
   * @return {Promise}         []
   */

  _default.prototype.count = function count(options) {
    var collection, where, group, order, aggregate, fn;
    return _regeneratorRuntime.async(function count$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.collection(options.table));

        case 2:
          collection = context$2$0.sent;
          where = this.parseWhere(options.where);
          group = this.group(options.group);

          group.total = { $sum: 1 };

          order = this.parseOrder(options.order);
          aggregate = [];

          if (!think.isEmpty(where)) {
            aggregate.push({ $match: where });
          }
          aggregate.push({ $group: group });
          if (!think.isEmpty(order)) {
            aggregate.push({ $sort: order });
          }
          //make aggregate method to be a promise
          fn = think.promisify(collection.aggregate, collection);
          return context$2$0.abrupt('return', fn(aggregate).then(function (data) {
            return data[0] && data[0].total || 0;
          }));

        case 13:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * get sum
   * @param  {Object} options []
   * @return {Promise}         []
   */

  _default.prototype.sum = function sum(options) {
    var collection, where, group, order, aggregate, fn;
    return _regeneratorRuntime.async(function sum$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.collection(options.table));

        case 2:
          collection = context$2$0.sent;
          where = this.parseWhere(options.where);
          group = this.group(options.group);

          group.total = { $sum: '$' + options.field };

          order = this.parseOrder(options.order);
          aggregate = [];

          if (!think.isEmpty(where)) {
            aggregate.push({ $match: where });
          }
          aggregate.push({ $group: group });
          if (!think.isEmpty(order)) {
            aggregate.push({ $sort: order });
          }
          //make aggregate method to be a promise
          fn = think.promisify(collection.aggregate, collection);
          return context$2$0.abrupt('return', fn(aggregate).then(function (data) {
            return data[0] && data[0].total || 0;
          }));

        case 13:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * create collection indexes
   * @param  {String} table   []
   * @param  {Object} indexes []
   * @return {Promise}         []
   */

  _default.prototype.ensureIndex = function ensureIndex(table, indexes) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    if (options === true) {
      options = { unique: true };
    }
    if (think.isString(indexes)) {
      indexes = indexes.split(/\s*,\s*/);
    }
    if (think.isArray(indexes)) {
      (function () {
        var result = {};
        indexes.forEach(function (item) {
          result[item] = 1;
        });
        indexes = result;
      })();
    }
    return this.collection(table).then(function (collection) {
      return collection.ensureIndex(indexes, options);
    });
  };

  /**
   * aggregate
   * @param  {String} table   []
   * @param  {Object} options []
   * @return {Promise}         []
   */

  _default.prototype.aggregate = function aggregate(table, options) {
    return this.collection(table).then(function (collection) {
      return collection.aggregate(options);
    });
  };

  /**
   * close socket
   * @return {} []
   */

  _default.prototype.close = function close() {
    if (this._socket) {
      this._socket.close();
      this._socket = null;
    }
  };

  return _default;
})(_parse_mongoJs2['default']);

exports['default'] = _default;
module.exports = exports['default'];

//get distinct field data

//delete one row