'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

//babel not export default property
//so can not use `import babel from 'babel-core'`
var babel = require('babel-core');

/**
 * watch compile
 */

var _default = (function (_think$base) {
  _inherits(_default, _think$base);

  function _default() {
    _classCallCheck(this, _default);

    _think$base.apply(this, arguments);

    this.compiledMtime = {};
    this.compiledErrorFiles = [];
  }

  /**
   * init
   * @param  {String} srcPath []
   * @param  {String} outPath []
   * @param  {Boolean} log     []
   * @return {}         []
   */

  _default.prototype.init = function init(srcPath, outPath, options, callback) {
    if (options === undefined) options = {};

    this.srcPath = srcPath;
    this.outPath = outPath;
    this.options = options;
    this.callback = callback;
  };

  /**
   * compile single file
   * @param  {String} file     []
   * @param  {Boolean} onlyCopy []
   * @return {}          []
   */

  _default.prototype.compileFile = function compileFile(file, onlyCopy) {
    var filePath = this.srcPath + '/' + file;
    var content = _fs2['default'].readFileSync(filePath, 'utf8');

    if (!content) {
      return;
    }
    if (onlyCopy) {
      _fs2['default'].writeFileSync(this.outPath + '/' + file, content);
      return;
    }

    var startTime = Date.now();
    try {
      var retainLines = this.options.retainLines;
      var data = babel.transform(content, {
        filename: file,
        retainLines: retainLines === undefined ? true : retainLines,
        stage: 0,
        modules: 'common',
        loose: true,
        optional: 'runtime'
      });
      if (this.options.log) {
        think.log('compile file ' + file, 'BABEL', startTime);
      }
      think.mkdir(_path2['default'].dirname(this.outPath + '/' + file));
      _fs2['default'].writeFileSync(this.outPath + '/' + file, data.code);
      return true;
    } catch (e) {

      think.log(function (colors) {
        return colors.red('compile file ' + file + ' error');
      }, 'BABEL');
      think.log(e);

      e.message = 'Babel Compile Error: ' + e.message;
      think.compileError = e;
    }
  };

  /**
   * src file is deleted, but app file also exist
   * then delete app file
   * @return {} []
   */

  _default.prototype.getSrcDeletedFiles = function getSrcDeletedFiles(srcFiles, appFiles) {
    var _this = this;

    return appFiles.filter(function (file) {
      var extname = _path2['default'].extname(file);
      if (extname !== '.js') {
        return;
      }
      //src file not exist
      if (srcFiles.indexOf(file) === -1) {
        var filepath = _this.outPath + '/' + file;
        _fs2['default'].unlinkSync(filepath);
        return true;
      }
    }).map(function (file) {
      return _this.outPath + '/' + file;
    });
  };

  /**
   * compile
   * @return {} []
   */

  _default.prototype.compile = function compile() {
    var _this2 = this;

    var files = think.getFiles(this.srcPath);
    var appFiles = think.getFiles(this.outPath);
    var changedFiles = this.getSrcDeletedFiles(files, appFiles);

    if (!this.compiledErrorFiles.length) {
      think.compileError = null;
    }

    files.forEach(function (file) {
      var extname = _path2['default'].extname(file);
      //if is not js file, only copy
      if (extname !== '.js') {
        _this2.compileFile(file, true);
        return;
      }
      var mTime = _fs2['default'].statSync(_this2.srcPath + '/' + file).mtime.getTime();
      var outFile = _this2.outPath + '/' + file;
      if (think.isFile(outFile)) {
        var outmTime = _fs2['default'].statSync(outFile).mtime.getTime();
        //if compiled file mtime is after than source file, return
        if (outmTime > mTime) {
          return;
        }
      }
      if (!_this2.compiledMtime[file] || mTime > _this2.compiledMtime[file]) {
        var ret = _this2.compileFile(file);
        if (ret) {
          changedFiles.push(_path2['default'].normalize(_this2.outPath + '/' + file));
        }

        _this2.compiledMtime[file] = mTime;

        if (ret) {
          var index = _this2.compiledErrorFiles.indexOf(file);
          if (index > -1) {
            _this2.compiledErrorFiles.splice(index, 1);
          }
        } else {
          _this2.compiledErrorFiles.push(file);
        }
      }
    });
    //notify auto reload service to clear file cache
    if (changedFiles.length && this.callback) {
      this.callback(changedFiles);
    }
    setTimeout(this.compile.bind(this), 100);
  };

  /**
   * run
   * @return {} []
   */

  _default.prototype.run = function run() {
    this.compile();
  };

  return _default;
})(think.base);

exports['default'] = _default;
module.exports = exports['default'];

/**
 * store compiled files last mtime
 * @type {Object}
 */

/**
 * compiled error files
 * @type {Array}
 */