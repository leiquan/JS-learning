'use strict';

/**
 * parallel limit
 */

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

exports.__esModule = true;

var _default = (function (_think$base) {
  _inherits(_default, _think$base);

  function _default() {
    _classCallCheck(this, _default);

    _think$base.apply(this, arguments);
  }

  /**
   * limit
   * @param  {[type]}   limit    []
   * @param  {Function} callback []
   * @return {[type]}            []
   */

  _default.prototype.init = function init(limit, callback) {
    if (think.isFunction(limit)) {
      callback = limit;
      limit = 0;
    }
    this.limit = limit || 10;
    this.index = 0;
    this.doing = 0;
    this.callback = callback;
    this.deferreds = [];
  };

  /**
   * add item data
   * @param {data} item []
   */

  _default.prototype.add = function add(item) {
    var deferred = think.defer();
    deferred.data = item;
    this.deferreds.push(deferred);
    this.run();
    return deferred.promise;
  };

  /**
   * add many data once
   * @param {Array} dataList [data array]
   */

  _default.prototype.addMany = function addMany(dataList, ignoreError) {
    var _this = this;

    if (think.isEmpty(dataList)) {
      return _Promise.resolve();
    }
    var promises = dataList.map(function (item) {
      var promise = _this.add(item);
      return ignoreError ? promise['catch'](function () {}) : promise;
    });
    return _Promise.all(promises);
  };

  /**
   * next
   * @return {Function} [description]
   */

  _default.prototype.next = function next() {
    this.doing--;

    //reduce deferreds avoid memory leak when use single item data
    this.deferreds.splice(this.index - 1, 1);
    this.index--;

    this.run();
  };

  /**
   * run
   * @return {} []
   */

  _default.prototype.run = function run() {
    var _this2 = this;

    if (this.doing >= this.limit || this.index >= this.deferreds.length) {
      return;
    }
    this.doing++;
    var item = this.deferreds[this.index++];
    var callback = think.isFunction(item.data) ? item.data : this.callback;
    if (!think.isFunction(callback)) {
      throw new Error('data item or callback must be a function');
    }
    var result = callback(item.data);
    if (!think.isPromise(result)) {
      result = _Promise.resolve(result);
    }
    return result.then(function (data) {
      _this2.next();
      //resolve item
      item.resolve(data);
    })['catch'](function (err) {
      _this2.next();
      //reject item
      item.reject(err);
    });
  };

  return _default;
})(think.base);

exports['default'] = _default;
module.exports = exports['default'];