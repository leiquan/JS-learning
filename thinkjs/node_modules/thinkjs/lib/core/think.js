'use strict';

var _Object$create = require('babel-runtime/core-js/object/create')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _this = this;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _thinkit = require('thinkit');

var _thinkit2 = _interopRequireDefault(_thinkit);

var _co = require('co');

var _co2 = _interopRequireDefault(_co);

var _colorsSafe = require('colors/safe');

var _colorsSafe2 = _interopRequireDefault(_colorsSafe);

var _baseJs = require('./base.js');

var _baseJs2 = _interopRequireDefault(_baseJs);

var _http_baseJs = require('./http_base.js');

var _http_baseJs2 = _interopRequireDefault(_http_baseJs);

require('./_cache.js');

var _utilCookieJs = require('../util/cookie.js');

var _utilCookieJs2 = _interopRequireDefault(_utilCookieJs);

/**
 * global think variable
 * @type {Object}
 */
global.think = _Object$create(_thinkit2['default']);

/**
 * camelCase string
 * @TODO move to thinkit package
 * @param  {String} str []
 * @return {String}     []
 */
think.camelCase = function (str) {
  if (str.indexOf('_') > -1) {
    str = str.replace(/_(\w)/g, function (a, b) {
      return b.toUpperCase();
    });
  }
  return str;
};
/**
 * server start time
 * @type {Number}
 */
think.startTime = Date.now();
/**
 * app dir name, can be set in init
 * @type {Object}
 */
think.dirname = {
  config: 'config',
  controller: 'controller',
  model: 'model',
  adapter: 'adapter',
  logic: 'logic',
  service: 'service',
  view: 'view',
  middleware: 'middleware',
  runtime: 'runtime',
  common: 'common',
  bootstrap: 'bootstrap',
  locale: 'locale'
};
/**
 * env
 * development | testing | production
 * @type {String}
 */
think.env = 'development';
/**
 * server port
 * @type {Number}
 */
think.port = 0;
/**
 * is command line
 * @type {String}
 */
think.cli = false;
/**
 * get locale
 * @type {String}
 */
think.lang = (process.env.LANG || '').split('.')[0].replace('_', '-');
/**
 * app mode
 * 0x0001: mini
 * 0x0002: normal
 * 0x0004: module
 * @type {Boolean}
 */
think.mode = 0x0001;
//mini mode, no module
think.mode_mini = 0x0001;
//normal mode
think.mode_normal = 0x0002;
//module mode
think.mode_module = 0x0004;
/**
 * thinkjs module lib path
 * @type {String}
 */
think.THINK_LIB_PATH = _path2['default'].normalize(__dirname + '/..');
/**
 * thinkjs module root path
 * @type {String}
 */
think.THINK_PATH = _path2['default'].dirname(think.THINK_LIB_PATH);
/**
 * thinkjs version
 * @param  {) []
 * @return {}         []
 */
think.version = (function () {
  var packageFile = think.THINK_PATH + '/package.json';

  var _JSON$parse = JSON.parse(_fs2['default'].readFileSync(packageFile, 'utf-8'));

  var version = _JSON$parse.version;

  return version;
})();
/**
 * module list
 * @type {Array}
 */
think.module = [];
/**
 * base class
 * @type {Class}
 */
think.base = _baseJs2['default'];
/**
 * get deferred object
 * @return {Object} []
 */
think.defer = function () {
  var deferred = {};
  deferred.promise = new _Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
};
/**
 * make callback function to promise
 * @param  {Function} fn       []
 * @param  {Object}   receiver []
 * @return {Promise}            []
 */
think.promisify = function (fn, receiver) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new _Promise(function (resolve, reject) {
      fn.apply(receiver, [].concat(args, [function (err, res) {
        return err ? reject(err) : resolve(res);
      }]));
    });
  };
};
/**
 * [description]
 * @param  {[type]} err [description]
 * @return {[type]}     [description]
 */
think.reject = function (err) {
  //delay to show error
  setTimeout(function () {
    think.log(err);
  }, 500);
  return _Promise.reject(err);
};

/**
 * check object is http object
 * @param  {Mixed}  obj []
 * @return {Boolean}      []
 */
think.isHttp = function (obj) {
  return !!(obj && think.isObject(obj.req) && think.isObject(obj.res));
};

/**
 * alias co module to think.co
 * @type {Object}
 */
think.co = _co2['default'];
/**
 * create class
 * @param {Object} methods [methods and props]
 */
var Class = think.Class;
think.Class = function (type, clean) {
  // create class
  // think.Class({})
  // think.Class({}, true)
  if (think.isObject(type)) {
    return clean === true ? Class(type) : Class(think.base, type);
  }
  // create class with superClass
  // think.Class(function(){}, {})
  else if (think.isFunction(type)) {
      return Class(type, clean);
    }

  //create type class
  return function (superClass, methods) {
    // think.controller();
    // think.controller({})
    if (think.isObject(superClass) || !superClass) {
      methods = superClass;
      superClass = type + '_base';
    }
    // think.controller('superClass', {})
    else if (think.isString(superClass)) {
        superClass = think.lookClass(superClass, type);
      }
    if (think.isString(superClass)) {
      superClass = think.require(superClass, true);
      // get class
      // think.controller('rest')
      if (!methods) {
        return superClass;
      }
    }
    return Class(superClass, methods);
  };
};
/**
 * look up class
 * @param  {String} type   [class type, model, controller, service]
 * @param  {String} module [module name]
 * @return {String}        []
 */
think.lookClass = function (name, type, module, base) {
  var names = name.split('/');
  switch (names.length) {
    // home/controller/base
    case 3:
      return think.require(name);
    // home/base
    case 2:
      return think.require(names[0] + '/' + type + '/' + names[1]);
    // base
    case 1:
      var clsPath = undefined,
          cls = undefined;
      // find from current module
      if (module) {
        clsPath = module + '/' + type + '/' + name;
        cls = think.require(clsPath, true);
        if (cls) {
          return cls;
        }
      }
      // find from common module
      module = think.mode !== think.mode_module ? think.config('default_module') : think.dirname.common;
      var list = [module + '/' + type + '/' + name, type + '_' + name, base || type + '_base'];
      list.some(function (item) {
        return cls = think.require(item, true);
      });
      return cls;
  }
};
/**
 * get common module path
 * think.getPath(undefined, think.dirname.controller)
 * think.getPath(home, think.dirname.model)
 * @return {String} []
 */
think.getPath = function (module) {
  var type = arguments.length <= 1 || arguments[1] === undefined ? think.dirname.controller : arguments[1];
  var prefix = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];

  switch (think.mode) {
    case think.mode_mini:
      return '' + think.APP_PATH + prefix + '/' + type;
    case think.mode_normal:
      var filepath = '' + think.APP_PATH + prefix + '/' + type;
      switch (type) {
        case think.dirname.controller:
        case think.dirname.logic:
        case think.dirname.service:
        case think.dirname.view:
          module = module || think.config('default_module');
          filepath += '/' + module;
          break;
      }
      return filepath;
    case think.mode_module:
      module = module || think.dirname.common;
      return '' + think.APP_PATH + prefix + '/' + module + '/' + type;
  }
};

/**
 * require module
 * @param  {String} name []
 * @return {mixed}      []
 */
think.require = function (name, flag) {
  if (!think.isString(name)) {
    return name;
  }
  // adapter or middle by register
  var Cls = thinkCache(thinkCache.ALIAS_EXPORT, name);
  if (Cls) {
    return Cls;
  }

  var load = function load(name, filepath) {
    var obj = think.safeRequire(filepath);
    if (think.isFunction(obj)) {
      obj.prototype.__filename = filepath;
    }
    if (obj) {
      thinkCache(thinkCache.ALIAS_EXPORT, name, obj);
    }
    return obj;
  };

  var filepath = thinkCache(thinkCache.ALIAS, name);
  if (filepath) {
    return load(name, _path2['default'].normalize(filepath));
  }
  // only check in alias
  if (flag) {
    return null;
  }
  filepath = require.resolve(name);
  return load(name, filepath);
};
/**
 * safe require
 * @param  {String} file []
 * @return {mixed}      []
 */
think.safeRequire = function (file) {
  // absolute file path is not exist
  if (_path2['default'].isAbsolute(file)) {
    if (!think.isFile(file)) {
      return null;
    }
    //when file is exist, require direct
    return require(file);
  }
  try {
    return require(file);
  } catch (err) {
    think.log(err);
  }
  return null;
};

/**
 * merge & parse config, support adapter & parser
 * @param  {} configs []
 * @return {}            []
 */
think.parseConfig = function () {
  var _think;

  for (var _len2 = arguments.length, configs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    configs[_key2] = arguments[_key2];
  }

  configs = configs.map(function (config) {
    config = think.extend({}, config);
    //check adapter config exist
    if (config.type && config.adapter) {
      var adapterConfig = config.adapter[config.type];
      config = think.extend(config, adapterConfig);
      delete config.adapter;
    }
    return config;
  });

  var config = (_think = think).extend.apply(_think, [{}].concat(configs));

  //check parser method
  if (!think.isFunction(config.parser)) {
    return config;
  }

  var ret = config.parser(config);
  delete config.parser;
  return think.extend(config, ret);
};

/**
 * prevent next process
 * @return {Promise} []
 */
var preventMessage = 'PREVENT_NEXT_PROCESS';
think.prevent = function () {
  var err = new Error(preventMessage);
  return _Promise.reject(err);
};
/**
 * check is prevent error
 * @param  {Error}  err [error message]
 * @return {Boolean}     []
 */
think.isPrevent = function (err) {
  return think.isError(err) && err.message === preventMessage;
};
/**
 * log
 * @TODO
 * @return {} []
 */
think.log = function (msg, type, showTime) {

  //when type or showTime is boolean
  //only show log when value is true
  if (type === false || showTime === false) {
    return;
  } else if (type === true) {
    type = '';
  } else if (showTime === true) {
    showTime = '';
  }

  var fn = function fn(d) {
    return ('0' + d).slice(-2);
  };

  var d = new Date();
  var date = d.getFullYear() + '-' + fn(d.getMonth() + 1) + '-' + fn(d.getDate());
  var time = fn(d.getHours()) + ':' + fn(d.getMinutes()) + ':' + fn(d.getSeconds());

  var dateTime = _colorsSafe2['default'].gray('[' + date + ' ' + time + '] ');
  if (showTime === null) {
    dateTime = '';
  }

  var preError = thinkCache(thinkCache.COLLECTION, 'prev_error');
  if (think.isError(msg)) {
    if (think.isPrevent(msg) || msg === preError) {
      return;
    }
    thinkCache(thinkCache.COLLECTION, 'prev_error', msg);
    console.error(dateTime + _colorsSafe2['default'].red('[Error] ') + msg.stack);
    return;
  } else if (think.isFunction(msg)) {
    msg = msg(_colorsSafe2['default']);
  } else if (think.isObject(msg) || think.isArray(msg)) {
    msg = JSON.stringify(msg);
  }
  // if(msg.length > 300){
  //   msg = msg.substr(0, 300) + '...';
  // }
  if (think.isNumber(showTime)) {
    var _time = Date.now() - showTime;
    msg += ' ' + _colorsSafe2['default'].green(_time + 'ms');
  }
  if (type) {
    console.log(dateTime + _colorsSafe2['default'].cyan('[' + type + '] ') + msg);
  } else {
    console.log(dateTime + msg);
  }
};

/**
 * get or set config
 * @return {mixed} []
 */
think.config = function (name, value, data) {

  var flag = false;
  //get module config
  if (data && think.isString(data)) {
    data = think.getModuleConfig(data);
  } else if (!data) {
    flag = true;
    data = thinkCache(thinkCache.CONFIG);
  }

  //if set common config, must sync to module config
  var setConfig = function setConfig(name, value) {
    var configs = [];
    if (flag) {
      configs = think.module.map(function (item) {
        return think.getModuleConfig(item);
      });
    }
    [data].concat(configs).forEach(function (itemData) {
      if (think.isObject(name)) {
        think.extend(itemData, name);
      } else if (think.isString(name)) {
        //name = name.toLowerCase();
        if (name.indexOf('.') === -1) {
          itemData[name] = value;
        } else {
          var names = name.split('.');
          itemData[names[0]] = itemData[names[0]] || {};
          itemData[names[0]][names[1]] = value;
        }
      }
    });
  };

  // get all config
  // think.config();
  if (name === undefined) {
    return data;
  }
  // merge config
  // think.config({name: 'welefen'})
  else if (think.isObject(name) || value !== undefined) {
      setConfig(name, value);
    }
    // set or get config
    else if (think.isString(name)) {
        //name = name.toLowerCase();
        //one grade config
        if (name.indexOf('.') === -1) {
          return data[name];
        }
        name = name.split('.');
        value = data[name[0]] || {};
        return value[name[1]];
      }
};
/**
 * get module config
 * @param  {String} module []
 * @return {Object}        []
 */
think.getModuleConfig = function () {
  var module = arguments.length <= 0 || arguments[0] === undefined ? think.dirname.common : arguments[0];

  //get module config from cache
  var moduleConfig = thinkCache(thinkCache.MODULE_CONFIG);
  if (module in moduleConfig) {
    return moduleConfig[module];
  }

  var rootPath = undefined;
  //get sys config
  if (module === true) {
    rootPath = think.THINK_LIB_PATH + '/config';
  } else {
    rootPath = think.getPath(module, think.dirname.config);
  }

  var fileFilters = ['config', 'route'];
  var dirFilters = ['env', 'sys'];
  //load conf
  var getConfig = function getConfig(configPath) {
    var config = {};
    if (!think.isDir(configPath)) {
      return config;
    }
    _fs2['default'].readdirSync(configPath).forEach(function (item) {
      if (think.isDir(configPath + '/' + item)) {
        if (dirFilters.indexOf(item) === -1) {
          var _think$extend;

          config = think.extend(config, (_think$extend = {}, _think$extend[item] = getConfig(configPath + '/' + item), _think$extend));
        }
        return;
      }
      item = item.slice(0, -3);
      if (item[0] === '_' || fileFilters.indexOf(item) > -1) {
        return;
      }
      var conf = think.safeRequire(configPath + '/' + item + '.js');
      if (conf) {
        var _think$extend2;

        config = think.extend(config, (_think$extend2 = {}, _think$extend2[item] = conf, _think$extend2));
      }
    });
    return config;
  };

  //config.js
  var config = think.safeRequire(rootPath + '/config.js');
  var envConfig = {},
      extraConfig = getConfig(rootPath);

  envConfig = think.safeRequire(rootPath + '/env/' + think.env + '.js');
  envConfig = think.extend(envConfig, getConfig(rootPath + '/env/' + think.env));

  //merge all configs
  config = think.extend({}, config, extraConfig, envConfig);
  //merge common configs to module
  if (module !== true) {
    config = think.extend({}, thinkCache(thinkCache.CONFIG), config);
  }

  //transform config
  var transforms = require(think.THINK_LIB_PATH + '/config/sys/transform.js');
  config = think.transformConfig(config, transforms);

  //set config to module cache
  thinkCache(thinkCache.MODULE_CONFIG, module, config);

  return config;
};
/**
 * transform config
 * @param  {Object} config []
 * @return {Object}        []
 */
think.transformConfig = function (config, transforms) {
  for (var key in transforms) {
    if (!(key in config)) {
      continue;
    }
    var value = transforms[key];
    if (think.isFunction(value)) {
      config[key] = value(config[key], config);
    } else {
      config[key] = think.transformConfig(config[key], value);
    }
  }
  return config;
};
/**
 * exec hook
 * @param  {String} name []
 * @return {}      []
 */
think.hook = function () {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  var name = args[0];
  var _args$1 = args[1];
  var http = _args$1 === undefined ? {} : _args$1;
  var data = args[2];

  //get hook data
  if (args.length === 1) {
    return thinkCache(thinkCache.HOOK, name) || [];
  }
  // set hook data
  // think.hook('test', ['middleware1', 'middleware2'])
  else if (think.isArray(http)) {
      if (data !== 'append' && data !== 'prepend') {
        thinkCache(thinkCache.HOOK, name, []);
      }
      http.forEach(function (item) {
        think.hook(name, item, data);
      });
      return;
    }
    //remove hook
    else if (http === null) {
        thinkCache(thinkCache.HOOK, name, []);
        return;
      }
      //set hook data
      else if (!think.isHttp(http)) {
          // think.hook('test', function or class);
          if (think.isFunction(http)) {
            var _name = 'middleware_' + think.uuid();
            think.middleware(_name, http);
            http = _name;
          }
          var hooks = thinkCache(thinkCache.HOOK, name) || [];
          if (data === 'append') {
            hooks.push(http);
          } else if (data === 'prepend') {
            hooks.unshift(http);
          } else {
            hooks = [http];
          }
          thinkCache(thinkCache.HOOK, name, hooks);
          return;
        }

  //exec hook
  var list = thinkCache(thinkCache.HOOK, name) || [];
  var length = list.length;
  if (length === 0) {
    return _Promise.resolve(data);
  }
  http._middleware = data;

  //exec middleware
  var execMiddleware = function execMiddleware() {
    var i, _data;

    return _regeneratorRuntime.async(function execMiddleware$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          i = 0;

        case 1:
          if (!(i < length)) {
            context$2$0.next = 9;
            break;
          }

          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(think.middleware(list[i], http, http._middleware));

        case 4:
          _data = context$2$0.sent;

          if (_data !== undefined) {
            http._middleware = _data;
          }

        case 6:
          i++;
          context$2$0.next = 1;
          break;

        case 9:
          return context$2$0.abrupt('return', http._middleware);

        case 10:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };

  return execMiddleware();
};
/**
 * create or exec middleware
 * @param  {Function} superClass []
 * @param  {Object} methods      []
 * @return {mixed}            []
 */
think.middleware = function () {
  for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  var superClass = args[0];
  var methods = args[1];
  var data = args[2];

  var length = args.length;
  var prefix = 'middleware_';

  var middlwares = thinkCache(thinkCache.MIDDLEWARE);
  // register functional or class middleware
  // think.middleware('parsePayLoad', function(){})
  if (think.isString(superClass) && think.isFunction(methods)) {
    thinkCache(thinkCache.MIDDLEWARE, superClass, methods);
    return;
  }
  // exec middleware
  // think.middleware('parsePayLoad', http, data)
  if (length >= 2 && think.isHttp(methods)) {
    var _name2 = superClass,
        http = methods;
    if (think.isString(_name2)) {
      // name is in middleware cache
      if (_name2 in middlwares) {
        var fn = middlwares[_name2];
        //class middleware must have run method
        if (think.isFunction(fn.prototype.run)) {
          var instance = new fn(http);
          return think.co(instance.run(data));
          //return think.co.wrap(instance.run).bind(instance)(data);
        } else {
            return think.co(fn(http, data));
            //return think.co.wrap(fn)(http, data);
          }
      } else {
          var Cls = think.require(prefix + _name2, true);
          if (Cls) {
            var instance = new Cls(http);
            return think.co(instance.run(data));
            //return think.co.wrap(instance.run).bind(instance)(data);
          }
          var err = new Error(think.locale('MIDDLEWARE_NOT_FOUND', _name2));
          return _Promise.reject(err);
        }
    } else if (think.isFunction(_name2)) {
      return think.co(_name2(http, data));
      //return think.co.wrap(name)(http, data);
    }
  }
  // get middleware
  // think.middleware('parsePayLoad')
  if (length === 1 && think.isString(superClass)) {
    if (superClass in middlwares) {
      return middlwares[superClass];
    }
    var cls = think.require(prefix + superClass, true);
    if (cls) {
      return cls;
    }
    throw new Error(think.locale('MIDDLEWARE_NOT_FOUND', superClass));
  }
  var middleware = thinkCache(thinkCache.COLLECTION, 'middleware');
  if (!middleware) {
    middleware = think.Class('middleware');
    thinkCache(thinkCache.COLLECTION, 'middleware', middleware);
  }
  // create middleware
  return middleware(superClass, methods);
};

/**
 * create, register, call adapter
 * @param  {String} name []
 * @return {void}      []
 */
think.adapter = function () {
  for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  var type = args[0];
  var name = args[1];
  var fn = args[2];

  var length = args.length,
      key = 'adapter_';
  if (length === 3) {
    //register adapter
    //think.adapter('session', 'redis', function(){})
    if (think.isFunction(fn)) {
      key += type + '_' + name;
      thinkCache(thinkCache.ALIAS_EXPORT, key, fn);
      return;
    }
    //create adapter
    //module.exports = think.adapter('session', 'memory', {})
    else if (think.isObject(fn)) {
        return think.Class(think.adapter(type, name), fn);
      }
  }
  //type has not _
  else if (length === 2 && think.isString(type) && type.indexOf('_') === -1) {
      //create adapter
      //module.exports = think.adapter('session', {})
      if (think.isObject(name)) {
        return think.Class(think.adapter(type, 'base'), name);
      }
      //get adapter
      //think.adapter('session', 'redis')
      else if (think.isString(name)) {
          key += type + '_' + name;
          var cls = think.require(key, true);
          if (cls) {
            return cls;
          } else {
            think.loadAdapter(type, name);
            var _cls = think.require(key, true);
            if (_cls) {
              return _cls;
            }
          }
          throw new Error(think.locale('ADAPTER_NOT_FOUND', key));
        }
    }

  //create adapter
  //module.exports = think.adapter({})
  //module.exports = think.adapter(function(){}, {});
  var superClass = undefined;
  if (think.isFunction(type)) {
    superClass = type;
  } else if (think.isString(type)) {
    superClass = think.require(type);
  }
  //create clean Class
  if (!superClass) {
    return think.Class(type);
  }
  return think.Class(superClass, name);
};
/**
 * load system & comon module adapter
 * @return {} []
 */
think.loadAdapter = function (type) {
  var name = arguments.length <= 1 || arguments[1] === undefined ? 'base' : arguments[1];

  var paths = [think.THINK_LIB_PATH + '/adapter'];

  //load base adapter
  think.adapter.base = require(paths[0] + '/base.js');

  //common module adapter
  var adapterPath = think.getPath(undefined, think.dirname.adapter);
  if (think.isDir(adapterPath)) {
    paths.push(adapterPath);
  }
  paths.forEach(function (path) {
    if (type) {
      var filepath = path + '/' + type + '/' + name + '.js';
      if (think.isFile(filepath)) {
        thinkCache(thinkCache.ALIAS, 'adapter_' + type + '_' + name, filepath);
      }
    } else {
      var dirs = _fs2['default'].readdirSync(path);
      dirs.forEach(function (dir) {
        if (!think.isDir(path + '/' + dir)) {
          return;
        }
        think.alias('adapter_' + dir, path + '/' + dir);
        //adapter type base class
        // let cls = think.require(`adapter_${dir}_base`, true);
        // if(cls){
        //   think.adapter[dir] = cls;
        // }
      });
    }
  });
};

/**
 * load alias
 * @param  {String} type  []
 * @param  {Array} paths []
 * @return {Object}       []
 */
think.alias = function (type, paths, slash) {
  if (!type) {
    return thinkCache(thinkCache.ALIAS);
  }
  //regist alias
  if (!think.isArray(paths)) {
    paths = [paths];
  }
  paths.forEach(function (path) {
    var files = think.getFiles(path);
    files.forEach(function (file) {
      if (file.slice(-3) !== '.js' || file[0] === '_') {
        return;
      }
      var name = file.slice(0, -3);
      name = type + (slash ? '/' : '_') + name;
      thinkCache(thinkCache.ALIAS, name, path + '/' + file);
    });
  });
};
/**
 * load route
 * route detail config
 *
 * module.exports = {
 *   admin: {
 *     reg: /^admin/, //module reg
 *     children: [
 *       /^admin\/reg/, 'admin/index/reg'
 *     ]
 *   },
 *   home: {
 *     children: [
 *       
 *     ]
 *   }
 * }
 * 
 * @return {} []
 */
think.route = function (routes) {
  var key = 'route';
  if (routes === null) {
    thinkCache(thinkCache.COLLECTION, key, null);
    return;
  }
  //set route
  else if (think.isArray(routes) || think.isObject(routes)) {
      thinkCache(thinkCache.COLLECTION, key, routes);
      return;
    }
  routes = thinkCache(thinkCache.COLLECTION, key);
  if (routes) {
    return routes;
  }
  var file = think.getPath(undefined, think.dirname.config) + '/route.js';
  var config = think.safeRequire(file) || [];

  //route config is funciton
  //may be is dynamic save in db
  if (think.isFunction(config)) {
    return think.await('route', function () {
      //let fn = think.co.wrap(config);
      //return fn().then((route = []) => {
      return think.co(config()).then(function () {
        var route = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

        thinkCache(thinkCache.COLLECTION, key, route);
        return route;
      });
    });
  }
  //get module route config
  else if (think.isObject(config) && think.mode === think.mode_module) {
      for (var _module2 in config) {
        var filepath = think.getPath(_module2, think.dirname.config) + '/route.js';
        var moduleConfig = think.safeRequire(filepath);
        config[_module2].children = moduleConfig || [];
      }
    }
  thinkCache(thinkCache.COLLECTION, key, config);
  return config;
};
/**
 * regist gc
 * @param  {Object} instance [class instance]
 * @return {}          []
 */
think.gc = function (instance) {
  var type = instance.gcType;
  var timers = thinkCache(thinkCache.TIMER);
  var gc = think.config('gc');
  if (!gc.on || type in timers) {
    return;
  }
  var timer = setInterval(function () {
    if (gc.filter()) {
      return instance.gc && instance.gc(Date.now());
    }
  }, gc.interval * 1000);
  thinkCache(thinkCache.TIMER, type, timer);
};

/**
 * get http object
 * @param  {Object} req [http request]
 * @param  {Object} res [http response]
 * @return {Object}     [http object]
 */
think._http = function () {
  var data = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  if (think.isString(data)) {
    if (data[0] === '{') {
      data = JSON.parse(data);
    } else if (/^\w+\=/.test(data)) {
      data = _querystring2['default'].parse(data);
    } else {
      data = { url: data };
    }
  }
  var url = data.url || '';
  if (url.indexOf('/') !== 0) {
    url = '/' + url;
  }
  var req = {
    httpVersion: '1.1',
    method: (data.method || 'GET').toUpperCase(),
    url: url,
    headers: think.extend({
      host: data.host || '127.0.0.1'
    }, data.headers),
    connection: {
      remoteAddress: data.ip || '127.0.0.1'
    }
  };
  var empty = function empty() {};
  var res = {
    setTimeout: empty,
    end: data.end || data.close || empty,
    write: data.write || data.send || empty,
    setHeader: empty
  };
  return {
    req: req,
    res: res
  };
};
/**
 * get http object
 * @param  {Object} req []
 * @param  {Object} res []
 * @return {Promise}     []
 */
think.http = function (req, res) {
  var Http = thinkCache(thinkCache.COLLECTION, 'http');
  if (!Http) {
    Http = think.require('http');
    thinkCache(thinkCache.COLLECTION, 'http', Http);
  }
  //for cli request
  if (res === undefined) {
    var _think$_http = think._http(req);

    req = _think$_http.req;
    res = _think$_http.res;
  }
  var instance = new Http(req, res);
  return instance.run();
};
/**
 * base class for has http property
 * @type {Class}
 */
think.http.base = _http_baseJs2['default'];

/**
 * get uuid
 * @param  {Number} length [uid length]
 * @return {String}        []
 */
think.uuid = function () {
  var length = arguments.length <= 0 || arguments[0] === undefined ? 32 : arguments[0];

  // length = length || 32;
  var str = _crypto2['default'].randomBytes(Math.ceil(length * 0.75)).toString('base64').slice(0, length);
  return str.replace(/[\+\/]/g, '_');
};
/**
 * start session
 * @param  {Object} http []
 * @return {}      []
 */
think.session = function (http) {
  //if session is init, return
  if (http._session) {
    return http._session;
  }

  // let Cookie = thinkCache(thinkCache.COLLECTION, 'cookie');
  // if (!Cookie) {
  //   Cookie = think.require('cookie');
  //   thinkCache(thinkCache.COLLECTION, 'cookie', Cookie);
  // }

  var sessionOptions = think.config('session');
  var name = sessionOptions.name;
  var secret = sessionOptions.secret;

  var cookie = http._cookie[name];

  //validate cookie sign
  if (cookie && secret) {
    cookie = _utilCookieJs2['default'].unsign(cookie, secret);
    //set cookie to http._cookie
    if (cookie) {
      http._cookie[name] = cookie;
    }
  }

  var sessionCookie = cookie;
  //generate session cookie when cookie is not set
  if (!cookie) {
    var options = sessionOptions.cookie || {};
    cookie = think.uuid(options.length || 32);
    sessionCookie = cookie;
    //sign cookie
    if (secret) {
      cookie = _utilCookieJs2['default'].sign(cookie, secret);
    }
    http._cookie[name] = sessionCookie;
    http.cookie(name, cookie, options);
  }

  var type = sessionOptions.type || 'memory';
  if (type === 'memory') {
    if (think.config('cluster_on')) {
      type = 'file';
      think.log('in cluster mode, session can\'t use memory for storage, convert to File');
    }
  }

  var conf = think.parseConfig(sessionOptions, {
    cookie: sessionCookie
  });
  var cls = think.adapter('session', type);
  var session = new cls(conf);
  http._session = session;

  //save session data after request end
  http.once('afterEnd', function () {
    return session.flush && session.flush();
  });
  return session;
};

/**
 * create controller sub class
 * @type {Function}
 */
think.controller = function (superClass, methods, module) {
  var isConfig = think.isHttp(methods) || module;
  // get controller instance
  if (think.isString(superClass) && isConfig) {
    var Cls = think.lookClass(superClass, 'controller', module);
    return new Cls(methods);
  }
  var controller = thinkCache(thinkCache.COLLECTION, 'controller');
  if (!controller) {
    controller = think.Class('controller');
    thinkCache(thinkCache.COLLECTION, 'controller', controller);
  }
  //create sub controller class
  return controller(superClass, methods);
};
/**
 * create logic class
 * @type {Function}
 */
think.logic = function (superClass, methods, module) {
  var isConfig = think.isHttp(methods) || module;
  //get logic instance
  if (think.isString(superClass) && isConfig) {
    var Cls = think.lookClass(superClass, 'logic', module);
    return new Cls(methods);
  }
  var logic = thinkCache(thinkCache.COLLECTION, 'logic');
  if (!logic) {
    logic = think.Class('logic');
    thinkCache(thinkCache.COLLECTION, 'logic', logic);
  }
  //create sub logic class
  return logic(superClass, methods);
};
/**
 * create model sub class
 * @type {Function}
 */
think.model = function (superClass, methods, module) {
  var isConfig = !!module;
  if (!isConfig && methods) {
    //check is db configs
    if ('host' in methods && 'type' in methods) {
      isConfig = true;
    }
  }
  //get model instance
  if (think.isString(superClass) && isConfig) {
    methods = think.extend({}, think.config('db'), methods);
    var _base = methods.type === 'mongo' ? 'model_mongo' : '';
    var cls = think.lookClass(superClass, 'model', module, _base);
    return new cls(superClass, methods);
  }
  var model = thinkCache(thinkCache.COLLECTION, 'model');
  if (!model) {
    model = think.Class('model');
    thinkCache(thinkCache.COLLECTION, 'model', model);
  }
  //create model
  return model(superClass, methods);
};

/**
 * create service sub class
 * @type {Function}
 */
think.service = function (superClass, methods, module) {
  //get service instance
  if (think.isString(superClass)) {
    return think.lookClass(superClass, 'service', module || methods);
  }
  var service = thinkCache(thinkCache.COLLECTION, 'service');
  if (!service) {
    service = think.Class('service');
    thinkCache(thinkCache.COLLECTION, 'service', service);
  }
  //create sub service class
  return service(superClass, methods);
};
/**
 * get or set cache
 * @param  {String} type  [cache type]
 * @param  {String} name  [cache name]
 * @param  {Mixed} value [cache value]
 * @return {}       []
 */
think.cache = function callee$0$0(name, value) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  var Cls, instance, data;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        options = think.extend({}, think.config('cache'), options);
        Cls = think.adapter('cache', options.type || 'memory');
        instance = new Cls(options);

        if (!(value === undefined)) {
          context$1$0.next = 7;
          break;
        }

        return context$1$0.abrupt('return', instance.get(name));

      case 7:
        if (!(value === null)) {
          context$1$0.next = 11;
          break;
        }

        return context$1$0.abrupt('return', instance['delete'](name));

      case 11:
        if (!think.isFunction(value)) {
          context$1$0.next = 23;
          break;
        }

        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(instance.get(name));

      case 14:
        data = context$1$0.sent;

        if (!(data !== undefined)) {
          context$1$0.next = 17;
          break;
        }

        return context$1$0.abrupt('return', data);

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(think.co(value(name)));

      case 19:
        data = context$1$0.sent;
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(instance.set(name, data));

      case 22:
        return context$1$0.abrupt('return', data);

      case 23:
        return context$1$0.abrupt('return', instance.set(name, value));

      case 24:
      case 'end':
        return context$1$0.stop();
    }
  }, null, _this);
};
/**
 * get locale message
 * @param  {String} key  []
 * @param  {String} lang []
 * @return {String}      []
 */
think.locale = function (key) {
  for (var _len6 = arguments.length, data = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
    data[_key6 - 1] = arguments[_key6];
  }

  var _default = think.config('locale.default');
  var lang = think.lang || _default;
  var config = think.config('locale');
  var value = undefined;
  if (config[lang] && config[lang][key]) {
    value = config[lang][key];
  } else if (config[_default][key]) {
    value = config[_default][key];
  } else {
    value = key;
  }
  var msg = _util2['default'].format.apply(_util2['default'], [value].concat(data));
  return msg;
};
/**
 * validate data
 * {
 *   name: {
 *     value: 'test',
 *     required: true,
 *     length: [4, 20],
 *     email: true
 *   },
 *   pwd: {
 *     value: '12345678',
 *     required: true,
 *     length: [6, 20]
 *   }
 *   confirm_pwd: {
 *     value: '12345678',
 *     required: true,
 *     equals: 'pwd'
 *   }
 * }
 * @param  {String | Object}   name     []
 * @param  {Function} callback []
 * @return {}            []
 */
think.validate = function (name, callback) {
  var Validator = thinkCache(thinkCache.VALIDATOR);
  if (think.isEmpty(Validator)) {
    Validator = think.require('validator');
    thinkCache(thinkCache.VALIDATOR, Validator);
  }
  // register validate callback
  if (think.isString(name)) {
    // think.validate('test', function(){})
    if (think.isFunction(callback)) {
      thinkCache(thinkCache.VALIDATOR, name, callback);
      return;
    }
    // get validator callback
    return thinkCache(thinkCache.VALIDATOR, name);
  }
  var data = name,
      msg = {},
      msgs = callback || {},
      item = undefined;

  //get error message
  var getMsg = function getMsg(type, name, value, args) {
    var key = 'validate_' + type;
    var keyWithName = key + '_' + name;
    var msg = msgs[keyWithName];
    if (!msg && think.locale(keyWithName) !== keyWithName) {
      msg = think.locale(keyWithName);
    }
    msg = msg || msgs[key];
    if (!msg && think.locale(key) !== key) {
      msg = think.locale(key);
    }
    if (!msg) {
      msg = think.locale('PARAMS_NOT_VALID');
    }
    return msg.replace('{name}', name).replace('{value}', value).replace('{args}', args.join(','));
  };

  //validate item rule
  var validateRule = function validateRule(name, type, value, args) {
    var fn = Validator[type];
    if (!think.isFunction(fn)) {
      throw new Error(think.locale('CONFIG_NOT_FUNCTION', type + ' type'));
    }
    if (think.isBoolean(args)) {
      args = [];
    } else if (!think.isArray(args)) {
      args = [args];
    }
    var msgArgs = [].concat(args);
    var parseArgs = Validator['_' + type];
    //parse args
    if (think.isFunction(parseArgs)) {
      args = parseArgs(args, data);
    }
    var result = fn.apply(undefined, [value].concat(args));
    if (!result) {
      msg[name] = getMsg(type, name, value, msgArgs);
    }
    return result;
  };

  var _loop = function (_name3) {
    item = data[_name3];

    var _loop2 = function (vitem) {
      if (vitem === 'value') {
        return 'continue';
      }
      //if has array rule, then foreach check value for every rule
      if ('array' in item && vitem !== 'array' && think.isArray(item.value)) {
        var flag = item.value.some(function (itemValue) {
          if (!validateRule(_name3, vitem, itemValue, item[vitem])) {
            return true;
          }
        });
        if (flag) {
          return 'break';
        }
      } else {
        if (!validateRule(_name3, vitem, item.value, item[vitem])) {
          return 'break';
        }
      }
    };

    _loop3: for (var vitem in item) {
      var _ret2 = _loop2(vitem);

      switch (_ret2) {
        case 'continue':
          continue;

        case 'break':
          break _loop3;}
    }
  };

  for (var _name3 in data) {
    _loop(_name3);
  }
  return msg;
};
/**
 * await 
 * @param  {String}   key      []
 * @param  {Function} callback []
 * @return {Promise}            []
 */
think.await = function (key, callback) {
  var awaitInstance = thinkCache(thinkCache.COLLECTION, 'await_instance');
  if (!awaitInstance) {
    var Await = think.require('await');
    awaitInstance = new Await();
    thinkCache(thinkCache.COLLECTION, 'await_instance', awaitInstance);
  }
  return awaitInstance.run(key, callback);
};

/**
 * install node package
 * @param  {String} pkg [package name]
 * @return {Promise}     []
 */
think.npm = function (pkg) {
  try {
    return _Promise.resolve(think.require(pkg));
  } catch (e) {
    var _ret3 = (function () {
      var pkgWithVersion = pkg;
      //get package version
      if (pkgWithVersion.indexOf('@') === -1) {
        var version = think.config('package')[pkg];
        if (version) {
          pkgWithVersion += '@' + version;
        }
      } else {
        pkg = pkgWithVersion.split('@')[0];
      }
      var cmd = 'npm install ' + pkgWithVersion + ' --save';
      return {
        v: think.await(cmd, function () {
          var deferred = think.defer();
          think.log('install package ' + pkgWithVersion + ' start', 'NPM');
          _child_process2['default'].exec(cmd, {
            cwd: think.ROOT_PATH
          }, function (err) {
            if (err) {
              think.log(new Error('install package ' + pkgWithVersion + ' error'));
              deferred.reject(err);
            } else {
              think.log('install package ' + pkgWithVersion + ' finish', 'NPM');
              deferred.resolve(think.require(pkg));
            }
          });
          return deferred.promise;
        })
      };
    })();

    if (typeof _ret3 === 'object') return _ret3.v;
  }
};
/**
 * get error
 * @param  {Error} err   []
 * @param  {String} addon []
 * @return {Error}       []
 */
think.error = function (err) {
  var addon = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

  if (think.isPromise(err)) {
    return err['catch'](function (err) {
      return think.reject(think.error(err, addon));
    });
  } else if (think.isError(err)) {
    var message = err.message;
    var errors = thinkCache(thinkCache.ERROR);
    var key = undefined,
        value = undefined,
        reg = /^[A-Z\_]$/;
    for (key in errors) {
      var pos = message.indexOf(key);
      if (pos > -1) {
        var prev = pos === 0 ? '' : message[pos - 1];
        var next = message[pos + key.length];
        if (!reg.test(prev) && !reg.test(next)) {
          value = errors[key];
          break;
        }
      }
    }
    if (value) {
      var siteMessage = 'http://www.thinkjs.org/doc/error_message.html#' + key.toLowerCase();
      if (think.isError(addon)) {
        addon.message = value + ', ' + addon.message + '. ' + siteMessage;
        return addon;
      } else {
        addon = addon ? ', ' + addon : '';
        var msg = '' + value + addon + '. ' + siteMessage;
        err.message = msg;
        return err;
      }
    }
    return err;
  } else {
    return new Error(err);
  }
};
/**
 * exec status action
 * @param  {Number} status []
 * @param  {Object} http   []
 * @return {}        []
 */
think.statusAction = function callee$0$0(status, http, log) {
  if (status === undefined) status = 500;
  var name, cls, instance;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!think.isPrevent(http.error)) {
          context$1$0.next = 2;
          break;
        }

        return context$1$0.abrupt('return');

      case 2:
        if (!http._error) {
          context$1$0.next = 7;
          break;
        }

        think.log(http.error);
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(http.status(status).end());

      case 6:
        return context$1$0.abrupt('return', think.prevent());

      case 7:
        http._error = true;

        if (log) {
          think.log(http.error);
        }

        name = think.config('default_module') + '/' + think.dirname.controller + '/error';

        if (think.mode === think.mode_module) {
          name = think.dirname.common + '/' + think.dirname.controller + '/error';
        }

        cls = think.require(name, true);

        if (cls) {
          context$1$0.next = 15;
          break;
        }

        http.error = new Error(think.locale('CONTROLLER_NOT_FOUND', name, http.url));
        return context$1$0.abrupt('return', think.statusAction(status, http, log));

      case 15:

        //set http status
        http.status(status);

        instance = new cls(http);
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(instance.invoke('_' + status + 'Action', instance));

      case 19:
        return context$1$0.abrupt('return', think.prevent());

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, _this);
};

/**
 * parallel limit exec
 * @param  {String}   key      []
 * @param  {Mixed}   data     []
 * @param  {Function} callback []
 * @return {}            []
 */
think.parallelLimit = function (key, data, callback) {
  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

  if (!think.isString(key) || think.isFunction(data)) {
    options = callback || {};
    callback = data;
    data = key;
    key = '';
  }
  if (!think.isFunction(callback)) {
    options = callback || {};
    callback = undefined;
  }
  if (think.isNumber(options)) {
    options = { limit: options };
  }

  var flag = !think.isArray(data) || options.array;
  if (!flag) {
    key = '';
  }

  //get parallel limit class
  var Limit = thinkCache(thinkCache.COLLECTION, 'limit');
  if (!Limit) {
    Limit = think.require('parallel_limit');
    thinkCache(thinkCache.COLLECTION, 'limit', Limit);
  }

  var instance = undefined;
  if (key) {
    instance = thinkCache(thinkCache.LIMIT, key);
    if (!instance) {
      instance = new Limit(options.limit, callback);
      thinkCache(thinkCache.LIMIT, key, instance);
    }
  } else {
    instance = new Limit(options.limit, callback);
  }

  if (flag) {
    return instance.add(data);
  }
  return instance.addMany(data, options.ignoreError);
};

// get cache

//delete cache

//get cache waiting for function

//data = await think.co.wrap(value)(name);

//set cache

//set error flag, avoid infinite loop

//error controller not found